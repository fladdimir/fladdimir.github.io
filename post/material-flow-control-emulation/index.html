<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python-based Emulation for Developing Material Flow Controls in C | wh</title>
<meta name=keywords content="Python,C,CFFI"><meta name=description content="Running C code as part of a Python simulation using CFFI"><meta name=author content><link rel=canonical href=https://fladdimir.github.io/post/material-flow-control-emulation/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://fladdimir.github.io/icon.png><link rel=icon type=image/png sizes=16x16 href=https://fladdimir.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://fladdimir.github.io/icon.png><link rel=apple-touch-icon href=https://fladdimir.github.io/apple-touch-icon.png><link rel=mask-icon href=https://fladdimir.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script data-goatcounter=https://fmghio.goatcounter.com/count async src=//gc.zgo.at/count.js></script><meta property="og:title" content="Python-based Emulation for Developing Material Flow Controls in C"><meta property="og:description" content="Running C code as part of a Python simulation using CFFI"><meta property="og:type" content="article"><meta property="og:url" content="https://fladdimir.github.io/post/material-flow-control-emulation/"><meta property="og:image" content="https://fladdimir.github.io/post/material-flow-control-emulation/featured.jpeg"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-08-23T00:00:00+00:00"><meta property="article:modified_time" content="2021-08-23T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://fladdimir.github.io/post/material-flow-control-emulation/featured.jpeg"><meta name=twitter:title content="Python-based Emulation for Developing Material Flow Controls in C"><meta name=twitter:description content="Running C code as part of a Python simulation using CFFI"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fladdimir.github.io/post/"},{"@type":"ListItem","position":2,"name":"Python-based Emulation for Developing Material Flow Controls in C","item":"https://fladdimir.github.io/post/material-flow-control-emulation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python-based Emulation for Developing Material Flow Controls in C","name":"Python-based Emulation for Developing Material Flow Controls in C","description":"Running C code as part of a Python simulation using CFFI","keywords":["Python","C","CFFI"],"articleBody":"Back at university we had a great time playing around with miniaturized Fischertechnik conveying systems. We learned about the challenges of PLC programming and the joy of using Arduino micro-controller boards to bring conveyor belts and turntables to life. We were learning about simulation-based controls testing using Emulate3D (awesome 3D physics engine, robot emulations) and Plant Simulation (also great for testing higher-level controls).\nHowever, the restrictive licensing - USB dongles and notoriously limited pool-licenses - made it challenging to create a simple and accessible controls development workflow suitable for all project team members.\nLet’s sketch the idea of a material flow simulation environment for developing, debugging and testing C-code inside a Python-based simulation model - non-proprietary and ready to be run anywhere, e.g. as part of CI.\nPublic repo: https://github.com/fladdimir/material-flow-control-c-emulation\n1. Scenario \u0026 Scope The “turntable” (image below) represents a typical Fischertechnik conveying module. It consists of 2 motors and 3 sensors:\nconveyor belt (motor 1) proximity sensor or photoelectric barrier to identify whether some item is present on the module (sensor 1) turning unit for changing the belt rotation by 90 degrees (motor 2) stop position sensors for checking whether the module fully rotated (sensors 2+3, both at 0 and 90 degrees) Even though the motors typically require 24V, relays can be used to control a module with a micro-controller boards typically working at 3-5V pin voltage. Micro-controller boards such as Arduinos also offer further options for interfacing with other systems via serial communication.\nPutting together multiple turntable modules, grid-like conveying layouts can be realized.\nHowever, writing control logic for Arduino can be challenging, especially since debugging code running on a connected board is not as simple. Additionally, central material flow control software also needs to be tested in interaction with module controls.\n2. System Structure A structure for controlling the flow of goods through a grid of connected turntable modules could look like this:\nevery turntable’s sensors and actors are controlled by a micro-controller (I/O) every micro-controller has a serial connection to communicate with a central material flow control server the server logic consists of different parts dedicated to communicating with connected modules, as well as central functions e.g. for pathfinding/routing of items through the system While systems such as Flexconveyor claim to work in a decentralized way without the need for a central “routing brain”, the described structure tries to shift all functions without hard real-time requirements from the micro-controllers to a central server (which makes particular sense when running on low-budget, resource-constrained boards such as the Arduino Uno).\n3. Emulation Interfaces Within the described setup, every micro-controller interacts with its environment via sensor-reads, actor-writes, and byte-wise serial-reads/writes. To be able to run the control logic on a development computer, the actual hardware-dependent read/write calls need to be replaced by interactions with simulated counterparts.\nOne way of achieving that using a Python-based emulation environment and exploiting the simple interfacing with C code could look like this:\nmodule control C code is called from a Python runtime with help of a generated CFFI wrapper device-dependent interaction methods are setup to call corresponding Python functions providing simulated inputs/outputs sensor-reads \u0026 actor-writes are run against a shared memory, which is also read/written by a simulation of the physical modules serial reads \u0026 writes are going to a pipe, which represents a connection to the server-side module agent a dedicated sub-process is created for every module control so that no global C variables are shared between different module controls CFFI allows for the simple creation of functions which are declared in C and called from Python, as well as the other way around. When generating the CFFI wrapper code, C header files can be used to prepare C functions to be called from Python. To be able to implement forward-declared C functions in Python, the follwing definition can be set:\nextern \"Python+C\" bool _light_barrier(); // provide info whether sensor is triggered This way, an implementing Python function can then be wired:\n@ffi.def_extern() def _light_barrier() -\u003e bool: return shared_array[LIGHT_BARRIER_IDX] # simulated value from memory instead of actual sensor 4. 2D-Simulation To be able to emulate physical interactions of the module control code, real system components need to be simulated. While there are Python wrappers for awesome (3D) physics engines such as chrono, this implementation just uses a minimal 2D engine with very limited physics.\nSupported features include:\nnested element structures in 2D cheap collision//overlap detection for certain combinations of simple geometries (rectangles, straights, points) relative transition and rotation movements of elements and child-elements movement limits (e.g. to realize max. 90 degrees of rotation for turntables) While an elements global position is determined by its local position relative to the parent-element it is attached to, the global position is cached to avoid recalculation for nested objects in case no position changes occured for any parent element.\nThe collision detection uses a simple 2-phase check, first checking cheap circumcycles to identify potentially colliding objects before performing a more expensive cohen-sutherland evaluation. Collisions are used in the simulation e.g. to identify when a box is hitting a light barrier, or which conveyor belt movements are changing a box’s position.\n5. Putting it all together The screencast shows an animation of a small sample test scenario consisting of several modules forwarding one box towards randomly chosen target modules (indicated by ‘X’):\nThe visualization is created with help of the Arcade game engine, which allows to simply step forward the simulation inside the game loop and animate the current state. In addition to the advent of the simulated time, the (C-coded) control loop of each module is invoked sequentially to allow a reaction to potential sensor state changes.\nOn the server-side of the control hierarchy, the forwarding/receiving of boxes between modules and the awaiting of modules to reach readiness is realized using asyncio coroutines.\nThe determination of which modules to visit in order to reach a distant target module is done with help of networkx and a corresponding graph constructed from the module locations.\nThe cool thing about all this: we can debug every single layer of the control code at any point in time!\nIn addition to normal Python debugging (part of the VS Code Python extension) of the server-side control code, we can attach a C (gcc) debugger to any of the module sub-processes running the C code.\nThis also works great from within VS Code, where we can even run different debugging sessions at the same time.\nBeing able to “look inside” the current state of a C module control makes it amazingly easy to discover bugs, such as the bad evaluation of commands received via serial communication, confirmation serial writes at bad times, plain wrong if-conditions, misplaced early returns etc..\nAs animation is fully optional, running a “headless” simulation can be easily used for validating checked-in control code agains a set of defined test scenarios / module layouts e.g. as part of a CI pipeline.\nLimits and Shortcomings Despite the good level of support for development and debugging, there are serious shortcomings of the presented approach, so that there still remains the need for properly testing the complete physical system:\nC code is run on a normal PC instead of a resource-constrained micro-controller, so e.g. memory usage should be carefully checked the defined “hardware abstraction layer” hides the complexity of actual communication hardware and technologies (pins/bus systems/rxtx/i2c/…) all control code is invoked sequentially and the simulation waits for all control loops to finish before the next time step, so real-time requirements should be checked with special care on the target hardware ","wordCount":"1258","inLanguage":"en","datePublished":"2021-08-23T00:00:00Z","dateModified":"2021-08-23T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://fladdimir.github.io/post/material-flow-control-emulation/"},"publisher":{"@type":"Organization","name":"wh","logo":{"@type":"ImageObject","url":"https://fladdimir.github.io/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fladdimir.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://fladdimir.github.io/tags/ title=/tags><span>/tags</span></a></li><li><a href=https://fladdimir.github.io/search title="/search (Alt + /)" accesskey=/><span>/search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fladdimir.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://fladdimir.github.io/post/>Posts</a></div><h1 class=post-title>Python-based Emulation for Developing Material Flow Controls in C</h1><div class=post-meta><span title='2021-08-23 00:00:00 +0000 UTC'>August 23, 2021</span>&nbsp;·&nbsp;6 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-scenario--scope>1. Scenario & Scope</a></li><li><a href=#2-system-structure>2. System Structure</a></li><li><a href=#3-emulation-interfaces>3. Emulation Interfaces</a></li><li><a href=#4-2d-simulation>4. 2D-Simulation</a></li><li><a href=#5-putting-it-all-together>5. Putting it all together</a><ul><li><a href=#limits-and-shortcomings>Limits and Shortcomings</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>Back at university we had a great time playing around with miniaturized <a href=https://en.wikipedia.org/wiki/Fischertechnik>Fischertechnik</a> conveying systems.
We learned about the challenges of PLC programming and the joy of using <a href=https://www.arduino.cc/>Arduino</a> micro-controller boards to bring conveyor belts and turntables to life.
We were learning about simulation-based controls testing using <a href=https://emulate3d.de/>Emulate3D</a> (awesome 3D physics engine, robot emulations) and <a href=https://www.plm.automation.siemens.com/global/de/products/manufacturing-planning/plant-simulation-throughput-optimization.html>Plant Simulation</a> (also great for testing higher-level controls).<br>However, the restrictive licensing - USB dongles and notoriously limited pool-licenses - made it challenging to create a simple and accessible controls development workflow suitable for all project team members.</p><p>Let&rsquo;s sketch the idea of a material flow simulation environment for developing, debugging and testing C-code inside a Python-based simulation model - non-proprietary and ready to be run anywhere, e.g. as part of CI.</p><blockquote><p>Public repo: <a href=https://github.com/fladdimir/material-flow-control-c-emulation>https://github.com/fladdimir/material-flow-control-c-emulation</a></p></blockquote><h2 id=1-scenario--scope>1. Scenario & Scope<a hidden class=anchor aria-hidden=true href=#1-scenario--scope>#</a></h2><p>The &ldquo;turntable&rdquo; (image below) represents a typical Fischertechnik conveying module. It consists of 2 motors and 3 sensors:</p><ul><li>conveyor belt (motor 1)</li><li>proximity sensor or photoelectric barrier to identify whether some item is present on the module (sensor 1)</li><li>turning unit for changing the belt rotation by 90 degrees (motor 2)</li><li>stop position sensors for checking whether the module fully rotated (sensors 2+3, both at 0 and 90 degrees)</li></ul><p><img loading=lazy src=featured.jpeg alt=featured></p><p>Even though the motors typically require 24V, relays can be used to control a module with a micro-controller boards typically working at 3-5V pin voltage.
Micro-controller boards such as Arduinos also offer further options for interfacing with other systems via serial communication.</p><p>Putting together multiple turntable modules, grid-like conveying layouts can be realized.</p><p>However, writing control logic for Arduino can be challenging, especially since debugging code running on a connected board is not as simple.
Additionally, central material flow control software also needs to be tested in interaction with module controls.</p><h2 id=2-system-structure>2. System Structure<a hidden class=anchor aria-hidden=true href=#2-system-structure>#</a></h2><p>A structure for controlling the flow of goods through a grid of connected turntable modules could look like this:</p><p><img loading=lazy src=./system_structure-control_structure_2.jpg alt=system_structure_controls></p><ul><li>every turntable&rsquo;s sensors and actors are controlled by a micro-controller (I/O)</li><li>every micro-controller has a serial connection to communicate with a central material flow control server</li><li>the server logic consists of different parts dedicated to communicating with connected modules, as well as central functions e.g. for pathfinding/routing of items through the system</li></ul><p>While systems such as <a href=https://www.flexlog.de/en/>Flexconveyor</a> claim to work in a decentralized way without the need for a central &ldquo;routing brain&rdquo;, the described structure tries to shift all functions without hard real-time requirements from the micro-controllers to a central server (which makes particular sense when running on low-budget, resource-constrained boards such as the Arduino Uno).</p><h2 id=3-emulation-interfaces>3. Emulation Interfaces<a hidden class=anchor aria-hidden=true href=#3-emulation-interfaces>#</a></h2><p>Within the described setup, every micro-controller interacts with its environment via sensor-reads, actor-writes, and byte-wise serial-reads/writes.
To be able to run the control logic on a development computer, the actual hardware-dependent read/write calls need to be replaced by interactions with simulated counterparts.</p><p>One way of achieving that using a Python-based emulation environment and exploiting the simple interfacing with C code could look like this:</p><p><img loading=lazy src=./system_structure-emulation_2.jpg alt=system_structure_emulation></p><ul><li>module control C code is called from a Python runtime with help of a generated CFFI wrapper</li><li>device-dependent interaction methods are setup to call corresponding Python functions providing simulated inputs/outputs</li><li>sensor-reads & actor-writes are run against a shared memory, which is also read/written by a simulation of the physical modules</li><li>serial reads & writes are going to a pipe, which represents a connection to the server-side module agent</li><li>a dedicated sub-process is created for every module control so that no global C variables are shared between different module controls</li></ul><p><a href=https://cffi.readthedocs.io/en/latest/>CFFI</a> allows for the simple creation of functions which are declared in C and called from Python, as well as the other way around.
When generating the CFFI wrapper code, C header files can be used to prepare C functions to be called from Python.
To be able to implement forward-declared C functions in Python, the follwing definition can be set:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;Python+C&#34;</span> <span class=kt>bool</span> <span class=nf>_light_barrier</span><span class=p>();</span> <span class=c1>// provide info whether sensor is triggered
</span></span></span></code></pre></div><p>This way, an implementing Python function can then be wired:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=nd>@ffi.def_extern</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>_light_barrier</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>shared_array</span><span class=p>[</span><span class=n>LIGHT_BARRIER_IDX</span><span class=p>]</span> <span class=c1># simulated value from memory instead of actual sensor</span>
</span></span></code></pre></div><h2 id=4-2d-simulation>4. 2D-Simulation<a hidden class=anchor aria-hidden=true href=#4-2d-simulation>#</a></h2><p>To be able to emulate physical interactions of the module control code, real system components need to be simulated.
While there are <a href=https://projectchrono.org/pychrono/>Python wrappers</a> for awesome (3D) physics engines such as <a href=https://github.com/projectchrono/chrono>chrono</a>, this implementation just uses a minimal 2D engine with very limited physics.</p><p>Supported features include:</p><ul><li>nested element structures in 2D</li><li>cheap collision//overlap detection for certain combinations of simple geometries (rectangles, straights, points)</li><li>relative transition and rotation movements of elements and child-elements</li><li>movement limits (e.g. to realize max. 90 degrees of rotation for turntables)</li></ul><p>While an elements global position is determined by its local position relative to the parent-element it is attached to, the global position is cached to avoid recalculation for nested objects in case no position changes occured for any parent element.<br>The collision detection uses a simple 2-phase check, first checking cheap circumcycles to identify potentially colliding objects before performing a more expensive cohen-sutherland evaluation.
Collisions are used in the simulation e.g. to identify when a box is hitting a light barrier, or which conveyor belt movements are changing a box&rsquo;s position.</p><h2 id=5-putting-it-all-together>5. Putting it all together<a hidden class=anchor aria-hidden=true href=#5-putting-it-all-together>#</a></h2><p>The screencast shows an animation of a small sample test scenario consisting of several modules forwarding one box towards randomly chosen target modules (indicated by &lsquo;X&rsquo;):</p><p><img loading=lazy src=emulation.gif alt="c-controlled turntable modules forwarding a box towards randomly chosen targets (indicated by &amp;lsquo;X&amp;rsquo;)"></p><p>The visualization is created with help of the <a href=https://api.arcade.academy/en/latest/>Arcade</a> game engine, which allows to simply step forward the simulation inside the game loop and animate the current state.
In addition to the advent of the simulated time, the (C-coded) control loop of each module is invoked sequentially to allow a reaction to potential sensor state changes.</p><p>On the server-side of the control hierarchy, the forwarding/receiving of boxes between modules and the awaiting of modules to reach readiness is realized using asyncio coroutines.<br>The determination of which modules to visit in order to reach a distant target module is done with help of <a href=https://networkx.org/>networkx</a> and a corresponding graph constructed from the module locations.</p><blockquote><p>The cool thing about all this: we can debug every single layer of the control code at any point in time!</p></blockquote><p>In addition to normal Python debugging (part of the VS Code Python extension) of the server-side control code, we can attach a C (gcc) debugger to any of the module sub-processes running the C code.<br>This also works great from within VS Code, where we can even run different debugging sessions at the same time.</p><p>Being able to &ldquo;look inside&rdquo; the current state of a C module control makes it amazingly easy to discover bugs, such as the bad evaluation of commands received via serial communication, confirmation serial writes at bad times, plain wrong if-conditions, misplaced early returns etc..</p><p>As animation is fully optional, running a &ldquo;headless&rdquo; simulation can be easily used for validating checked-in control code agains a set of defined test scenarios / module layouts e.g. as part of a CI pipeline.</p><h3 id=limits-and-shortcomings>Limits and Shortcomings<a hidden class=anchor aria-hidden=true href=#limits-and-shortcomings>#</a></h3><p>Despite the good level of support for development and debugging, there are serious shortcomings of the presented approach, so that there still remains the need for properly testing the complete physical system:</p><ul><li>C code is run on a normal PC instead of a resource-constrained micro-controller, so e.g. memory usage should be carefully checked</li><li>the defined &ldquo;hardware abstraction layer&rdquo; hides the complexity of actual communication hardware and technologies (pins/bus systems/rxtx/i2c/&mldr;)</li><li>all control code is invoked sequentially and the simulation waits for all control loops to finish before the next time step, so real-time requirements should be checked with special care on the target hardware</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://fladdimir.github.io/tags/python/>Python</a></li><li><a href=https://fladdimir.github.io/tags/c/>C</a></li><li><a href=https://fladdimir.github.io/tags/cffi/>CFFI</a></li></ul><nav class=paginav><a class=prev href=https://fladdimir.github.io/post/stack-2022/><span class=title>« Prev</span><br><span>Credit-Card-Free Web Application Stack for 2022</span>
</a><a class=next href=https://fladdimir.github.io/post/location-sharing/><span class=title>Next »</span><br><span>Playing around with React, Leaflet, Micronaut, Okta, & Heroku</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://fladdimir.github.io/>wh</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>