<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Green-Light Optimized Speed Advisory for Cycling in Hamburg | wh</title>
<meta name=keywords content="Java,Spring,React,TypeScript,Leaflet.js,Tracing,MQTT,NodeJS,OGC SensorThings API"><meta name=description content="A web-app to reduce traffic-light waiting time on the daily bike ride to work"><meta name=author content><link rel=canonical href=https://fladdimir.github.io/post/glosa/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://fladdimir.github.io/icon.png><link rel=icon type=image/png sizes=16x16 href=https://fladdimir.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://fladdimir.github.io/icon.png><link rel=apple-touch-icon href=https://fladdimir.github.io/apple-touch-icon.png><link rel=mask-icon href=https://fladdimir.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script data-goatcounter=https://fmghio.goatcounter.com/count async src=//gc.zgo.at/count.js></script><meta property="og:title" content="Green-Light Optimized Speed Advisory for Cycling in Hamburg"><meta property="og:description" content="A web-app to reduce traffic-light waiting time on the daily bike ride to work"><meta property="og:type" content="article"><meta property="og:url" content="https://fladdimir.github.io/post/glosa/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-06-26T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-26T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Green-Light Optimized Speed Advisory for Cycling in Hamburg"><meta name=twitter:description content="A web-app to reduce traffic-light waiting time on the daily bike ride to work"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fladdimir.github.io/post/"},{"@type":"ListItem","position":2,"name":"Green-Light Optimized Speed Advisory for Cycling in Hamburg","item":"https://fladdimir.github.io/post/glosa/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Green-Light Optimized Speed Advisory for Cycling in Hamburg","name":"Green-Light Optimized Speed Advisory for Cycling in Hamburg","description":"A web-app to reduce traffic-light waiting time on the daily bike ride to work","keywords":["Java","Spring","React","TypeScript","Leaflet.js","Tracing","MQTT","NodeJS","OGC SensorThings API"],"articleBody":"Hurrying up right before an intersection just to narrowly miss the green light by a few seconds is one of the annoying things which regularly happen when cycling in the city.\nWouldn’t it be just great to know in advance whether a green phase may be catched, and to avoid useless acceleration and waiting phases?\nOver the last years, the city of Hamburg (Germany) has put some significant work into their Urban Data Platform and the geo-portal, improving the accessibility of various data sources.\nIn particular, the Traffic Lights Data Hamburg beta API provides access to real-time signal data of traffic-light systems for a large number of intersections in the city center.\nSo let’s see what we can get out of that data, and whether we may ease some pain of the daily ride.\nGreen-light optimized speed advisory The core idea of green-light optimized speed advisory (“GLOSA”) is to reduce unnecessary stops and accelerations by calculating reasonable movement speeds based on expected future green-light periods of upcoming traffic-lights.\nRecently, a couple of implementations have been developed in different cities.\nSome examples:\nGevas launched their app traffic pilot which is available i.a. in Duesseldorf, Frankfurt, Salzburg and Kassel Audi provides a GLOSA traffic assistant for their cars in selected cities (i.a. Ingolstadt, Duesseldorf, and New York (US)) the PrioBike project in Hamburg includes the PrioBike app as well as the PrioBike-Säule (see photo below; a fixed post comprised of a sensor and display to show speed advice to cyclists passing by).\nThe PrioBike app is developed by the TU Dresden and is currently (06/23) in closed beta (unfortunately, my registration mail has not been answered yet, however, an official statement confirms a planned release later in 2023).\nThe fixed post has been developed together with the company yunex traffic. Unfortunately, currently (06/2023) none of the app solutions is publically available in Hamburg.\nOne “PrioBike-Säule” has been installed close to the Hamburg-Dammtor train station, and judging from limited own experience it seems to work pretty well!\n(3 out of 4 times it actually showed a fully correct recommendation to catch the next green traffic-light. Sadly, it’s not part of my regular cycling routes.)\nAvailable traffic-lights data in Hamburg The geo-portal is an interactive map which can visualize some of the data made available by the city of Hamburg.\nThe screenshot below shows real-time traffic-light data of the intersection Fruchtallee / Doormannsweg:\nColors indicate the current signal of traffic-lights of different lanes.\nCorresponding data is provided for about 800 of 1770 traffic-lights in Hamburg:\nThe data is made available on https://tld.iot.hamburg.de/v1.1 via the standard OGC SensorThings API which is described in detail e.g. here (usage guide).\nThis paper gives an excellent overview on the system architecture and underlying infrastructure.\nThe map below shows a part of the route I used to cycle to work as well as markers for all traffic-lights for which real-time data is currently available:\nOverall, 13 out of 21 traffic-lights on the route provide real-time data (some are currently disabled due to ongoing construction work, and some may just be too small to be prioritized when planning corresponding IoT equipment. Nevertheless, having speed recommendations for almost two thirds of the encountered traffic-lights could already be a nice thing.)\nTo give an impression of provided traffic-light real-time data, the following bokeh-chart shows some historical data for the relevant primary signal (south -\u003e north) of the above-mentioned intersection Fruchtallee / Doormannsweg (the most westward on the route, with ID 813_19, Datastream-ID 50850), on a typical morning (Friday, 19.05.2023, 6:00-8:00 UTC):\n(\u003e interactive chart)\nThe y-axis shows the duration of a phase over time (x-axis). Blue indicates the length of complete cycles (red-to-red), and is calculated from the sum of the durations of the different phases, drawn in their corresponding colors. Dashed lines indicate average values over the time-period (arithmetic mean).\nOn average, a complete cycle took about 90s and the traffic-light showed red about 63s, green for about 23s, and the transitions (amber / red-amber) only account for 3s and 1s respectively.\nThat makes sense, given that the analyzed traffic-light is pointing towards the lanes going from south to north, while the majority of (car-)traffic at that time can be expected to go from west to east towards the city center.\nThe observations show a number of larger deviations from the mean, with green phases being almost twice as long as normal (over 40s, at 06:30 and 07:20), followed by accordingly shorter red phases (only slightly longer than 40s).\nThese deviations may be explained by a dynamic traffic-lights control system, which may extend certain phase durations e.g. to account for bus signal requests (“bus priorization”), or when detecting extraordinarily high volumes of car traffic going into a specific direction.\nAccording to a small sample of own observations, recent data is online available via the API in about 1-2s after a signal phase change.\nIn addition to the described real-time traffic-light data for car signals, the API also provides further information e.g. on car detectors, bus signal requests, pedestrian signals, and pedestrian signal requests.\nProof-of-Concept: A simple GLOSA web-app Given quality and quantity of the available data, it does not seem impossible to imagine using it to forecast relevant future signal-phase changes and to calculate reasonable movement speeds from that information.\nBelow, a small application is sketched which allows a mobile web-client to request speed recommendations:\nThe main flow of information looks as follows:\na client requests a speed-advice, submitting its current location, movement speed, and trip-id based on the trip-id the server can lookup the predefined route and determine the next upcoming traffic-light the latest signal-phase change times can be queried from the traffic-lights-data API (encapsulated by a locally running proxy-service) based on the received observations, a forecast of future phase changes can be created (also outsourced to a dedicated service) the forecast is used to determine the movement speed necessary to catch the next reachable green phase and that information is returned to the client whenever the client location updates, a new GLOSA-request is sent (see step 1., limited to at most 1 request per second) For the proof-of-concept, the initial route configuration requires some manual effort for importing a defined route (in form of a .gpx file), and for identifying relevant traffic-lights (IDs) with help of the geo-portal.\nThe next screenshot shows a minimal web UI which provides information about the current location of the device, the next traffic-light (currently showing red), as well as the speed recomendation (“slow down, its not getting green anytime soon..”):\nA couple of seconds later, the signal switched to green, and the current speed is sufficient to catch the phase:\nGPS-independent testing To facilitate manual testing without being reliant on actual GPS signals, the UI allows for the simulation of movements by dragging the user marker on the map:\nThere should have been a video here but your browser does not seem to support it. For manual testing, the current speed and the accuracy are set to 20 km/h and 10m.\nUsed technologies The client is built with React Material UI components, react-router, Leaflet for map display and interaction (via react-leaflet), and the browser Geolocation API (consent and secure context required).\nSince the Geolocation API does not work in the background a wakelock can be requested.\nAt the server-side, nginx provides basic authentication, ssl-termination, serves static frontend files, and forwards /api-requests.\nA “main backend service” is used for central calculations and the “orchestration” of auxiliary services, built with Spring Boot (which recently released the amazing support for compiling to a native-image, even though some stumbling blocks seem to remain).\nAccess to the latest traffic-light data is implemented using express running on node.js.\nFuture phase change times are forecasted based on the naive expectation of average-length phases, implemented in Python with pandas and exposed via flask.\nFor simple testing during development, the public localtunnel service can be used. This way, a server running at home can be accessed e.g. via mobile network (although they recently had to add some annoying password inquiry on their consent page).\nThe repository is available on github.\nGPS accuracy and “route snapping” One of the interesting aspects relates to the fact that the position the client detects is always somehow offset from the predefined route, be it due to measurement inaccuracies (commonly up to a couple of meters when using GPS), or inaccurate route definitions.\nConsider the following part of a piece-wise linear route R1-R4 and the corresponding measurement L:\nL indicates the current location sent by the client device, moving along the predefined route R1-R2-R3-R4. To give a speed recommendation, the next traffic-light (TL1 at R4) needs to be identified, and the correct distance along the given route must be calculated.\nTo determine the current location on the route, potential “snap locations” (SL1=R1, SL2, SL3) are evaluated by calculating the distance to the closest point on each segment (SL2 in the example above). The performed “route snapping” of the sent location is similar to (although simpler than) what some maps APIs offer, e.g. OSRMs match service.\nTo speed up the calculation, each segment is assumed to be linear, so that the JTS Topology Suite Java library’s DistanceOp can be used (with converted Mercator-coordinates as a fast simplification).\nPerformance considerations As the sketched system relies on frequent client-server-communication (~1 request per client per second), performant request handling is of high importance.\nFor basic analysis of server-side request processing, the open telemetry project provides standard tooling which makes it easy to gather tracing information. This is especially interesting since a client request causes multiple requests to different backend services (database, traffic-lights data API, forecasting service).\nInstrumentation support for automatic trace collection and forwarding to a tracing analysis backend are available for many popular languages / frameworks. For the main Java service, the Java instrumentation agent is used, which injects bytecode so that tracing information is automatically collected for popular frameworks / libraries without any code changes. Similar auto-instrumentation functionality is available for the node.js based traffic-lights data API proxy service, and for the Python-based forecast-service.\nThe following screenshot shows the processing of a single GLOSA-request:\nThe complete POST to the main backend (locationtracking-0.0.1-SNAPSHOT) takes 105ms to complete, starting with some database accesses (first ~10ms), followed by a long-running 69ms call to the traffic-lights data API proxy service (tld_api), and a 14ms call to the forecasting service (tld_forecast). As we can see, the main share of the overall request processing time is caused by the call to the external traffic-lights data API (68ms), out of which creating the TCP connection and completing the TLS handshake alone require 39ms.\nTo improve performance and efficiency of the external data API access, we can use a second feature of the sensorthings API. Apart from the normal HTTP-API to access historical data of traffic-light signal phase changes, a (websocket-based) MQTT-API allows to subscribe to new updates of specific traffic-lights. This way, we can extend the functionality of our API proxy service as follows:\nan initial request of the last N signal phase change timestamps causes a regular HTTP request to the external API to fetch the required observations (which are then returned to the client) furthermore, the received data is cached, and an MQTT-subscription for future updates is created each received update is used to update the cache (evicting the oldest entry) each following client-request for the same traffic-light data can now immediately be answered with locally cached data, without causing any external API request after a configurable time without any client requests for data of a specific traffic-light (e.g. 60s), its subscription is canceled and its cache is cleared (a following client request is again causing an initial external request (1.)) The following screenshot shows the processing of a second client request for the same traffic-light data:\nAs we can see, the request to the tld_api is processed within 3ms, without any external call.\nAssuming that data is requested over the last 1km when approaching a traffic-light, going with 20km/h (3 min travel time), and a frequency of 1 request per second, this means that 180 client requests only cause 1 initial external request and 179 subsequent requests are answered from the cache which is updated by push notifications received via MQTT. Consequently, the average request processing time for clients can be reduced by more than 50% (68/105ms), and the load for the external API server can be drastically reduced (even more when assuming multiple clients request the same traffic-light data).\nAs a further optimization, a server-push technology may be used to avoid polling and to allow for immediate client-notifications on the arrival of new data which causes changes to the last pushed recommendation.\nAs a disadvantage, the API proxy service now occupies a long-running MQTT-subscription / web-socket connection to the external API server (which should not cause much performance problems, as modern web-servers / MQTT brokers can be expected to easily handle large numbers of concurrent of connections, even on commodity hardware). Additionally, a subscription is kept alive some time after the last client request occured (as we cannot know whether there will be more), so that a couple of updates can be expected to be received unnecessarily - however, that disadvantage should be more than counterbalanced by the amount of saved external requests.\nApart from the external request handling, further optimization possibilities include database access and calculations at the stateless main backend service. Instead of loading the predefined route from the database on each client request, corresponding accesses can also be cached, e.g. using Springs built-in caching capabilities. As there is currently no way to modify predefined routes, their immutability avoids the need for cache invalidation. Even though there were no detailed measurements, it seems that a couple of milliseconds of request processing time may be saved this way.\nTo reduce the calculation effort of the “route snapping”, the index of the last reached route-segment is submitted back to the client as part of the response, so that this information can be included into a following request. This way, the number of checked route-segments can be limited, based on the assumption that a client is not expected to move backwards on a route. Additionally, checking further upcoming route-segments can be aborted once the closest distance to the current location stops to decrease (or does increase over a threshold), so that checking all upcoming route-segments can be avoided (at the expense of possibly missing an even closer segment). Other optimizations may include reducing the number of segments on a route by combining adjacent segments with (almost) identical direction into a single segment.\nWhile the described calculation optimizations may be relevant for longer routes with more segments (i.a. GPS waypoints), there was no measurable difference on the test route when reducing from 522 to 310 waypoints.\nExperimental evaluation To be able to quantify the effects of using the GLOSA app, the geolocation and speed data sent with each request is persisted for analysis.\nThe following chart shows the speed profile of a bike ride to work without following the GLOSA speed recommendations:\nThe trip had a duration of 00:32:16, and during this time 1,937 samples were collected (almost exactly one GPS update per second).\nThe theoretical distance measured on a map is 10.7 km, the total sum of the distances between all sampled locations is 11.1 km (slightly longer, probably due to GPS inaccuracies and seemingly “less straight” movements).\nGiven the duration and (theoretical) distance of the trip, an average speed of 5.53 m/s (19.90 km/h) can be calculated. This is close to the average speed calculated from the 1,937 speed samples (5.38 m/s), so the measurements seem to be quite accurate.\nThe maximum measured speed was 9.30 m/s (33.47 km/h), the share of samples with a measured speed below 1 km/h (likely stops) was 10.8%.\nThe next screenshot shows a trip when trying to follow the GLOSA recommendations:\nTo my disappointment, the share of speed measurements below 1 km/h is still 9.2% - a difference of 1.6 percentage points which may not be interpreted to be of any significance.\nObviously, any serious evaluation should be based on a larger number of trips. Furthermore, the experiment itself was probably also negatively influenced by existing personal experience on the common phase lengths. (Infact, some traffic lights along the route are already quite well-known, so that no external GLOSA recommendation is needed. Any serious evaluation should of course be performed on routes which are unknown to the testers.)\nWhile I did not analyse any more specific data, it seems that the effect of using the GLOSA app is negatively influenced by:\nbad traffic light data for some traffic lights (the “real-time” data is so old that no meaningful predications can be made) badly correlated traffic lights (no matter how slow/quick you try to go, between some traffic lights stops are almost inevitable; the phases seem to be optimized for a limited number of cars driving 50 km/h) “Bedarfsampeln” (one traffic light on the route only switches to green upon manual triggering, thus also causing unavoidable stops) bad predictions (forecasts purely based on historical data tend to be rather inaccurate, given the dynamic traffic control with adaptive phase lengths) Especially the last point causes a particularly frustrating experience in case a green phase could actually have easily been catched when not following a recommendation.\nConclusion While digging into the topic, it was quite surprising how and what data is made publically available by the Urban Data Platform of Hamburg. It’s good to see the municipality investing into the digitalization of the traffic-light infrastructure, and also into an IT infrastructure which may make large-scale applications possible.\nConcerning GLOSA applications, the practical benefit really depends on the decisive details - predicting the correct phase change times down to the second is a crucial aspect which seems quite hard to get right in this dynamic environment. Nevertheless, I am looking forward to the PrioBike app and may give it a try after its publically released (hopefully open-source).\nPotential extensions and improvements Based on the sketched proof-of-concept, numerous improvements are imaginable.\nStarting with the annoying manual setup step to define routes and to identify relevant traffic-light signal head IDs, the identification step could be automated as shown by the PrioBike-app developers from the TU Dresden in their selector implementation.\nA main challenge relates to the prediction of future signal phase changes, which could e.g. be extended by incorporating already available data such as bus signal requests.\nAnother potential for improvement relates to recommendation algorithms, which could e.g. include information on current/past riding speeds, as well as multiple upcoming traffic-lights (maybe the traffic-light right after the next one will be missed anyway).\nFinally - to generally improve the cycling experience and the quality of life in the city as a whole - other measures like optimizing traffic-light controls towards an average speed of 20-25 km/h, as well as simply extending the cycling lanes can obviously be expected to have a much greater impact than any GLOSA application.\n","wordCount":"3165","inLanguage":"en","datePublished":"2023-06-26T00:00:00Z","dateModified":"2023-06-26T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://fladdimir.github.io/post/glosa/"},"publisher":{"@type":"Organization","name":"wh","logo":{"@type":"ImageObject","url":"https://fladdimir.github.io/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fladdimir.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://fladdimir.github.io/tags/ title=/tags><span>/tags</span></a></li><li><a href=https://fladdimir.github.io/search title="/search (Alt + /)" accesskey=/><span>/search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fladdimir.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://fladdimir.github.io/post/>Posts</a></div><h1 class=post-title>Green-Light Optimized Speed Advisory for Cycling in Hamburg</h1><div class=post-meta><span title='2023-06-26 00:00:00 +0000 UTC'>June 26, 2023</span>&nbsp;·&nbsp;15 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#green-light-optimized-speed-advisory>Green-light optimized speed advisory</a></li><li><a href=#available-traffic-lights-data-in-hamburg>Available traffic-lights data in Hamburg</a></li><li><a href=#proof-of-concept-a-simple-glosa-web-app>Proof-of-Concept: A simple GLOSA web-app</a><ul><li><a href=#gps-independent-testing>GPS-independent testing</a></li><li><a href=#used-technologies>Used technologies</a></li><li><a href=#gps-accuracy-and-route-snapping>GPS accuracy and &ldquo;route snapping&rdquo;</a></li><li><a href=#performance-considerations>Performance considerations</a></li><li><a href=#experimental-evaluation>Experimental evaluation</a></li></ul></li><li><a href=#conclusion>Conclusion</a><ul><li><a href=#potential-extensions-and-improvements>Potential extensions and improvements</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>Hurrying up right before an intersection just to narrowly miss the green light by a few seconds is one of the annoying things which regularly happen when cycling in the city.</p><p>Wouldn&rsquo;t it be just great to know in advance whether a green phase may be catched, and to avoid useless acceleration and waiting phases?</p><p>Over the last years, the city of Hamburg (Germany) has put some significant work into their <a href=https://www.en.urbandataplatform.hamburg/>Urban Data Platform</a> and the <a href=https://geoportal-hamburg.de/geo-online/>geo-portal</a>, improving the accessibility of various data sources.</p><p>In particular, the <a href=https://tld.iot.hamburg.de/v1.1>Traffic Lights Data Hamburg beta API</a> provides access to real-time signal data of traffic-light systems for a large number of intersections in the city center.</p><p>So let&rsquo;s see what we can get out of that data, and whether we may ease some pain of the daily ride.</p><h2 id=green-light-optimized-speed-advisory>Green-light optimized speed advisory<a hidden class=anchor aria-hidden=true href=#green-light-optimized-speed-advisory>#</a></h2><p>The core idea of green-light optimized speed advisory (&ldquo;GLOSA&rdquo;) is to reduce unnecessary stops and accelerations by calculating reasonable movement speeds based on expected future green-light periods of upcoming traffic-lights.</p><p>Recently, a couple of implementations have been developed in different cities.<br>Some examples:</p><ul><li><a href=https://www.gevas.eu/>Gevas</a> launched their app <a href=https://www.trafficpilot.eu/>traffic pilot</a> which is available i.a. in Duesseldorf, Frankfurt, Salzburg and Kassel</li><li><a href=https://www.audi-mediacenter.com/de/pressemitteilungen/audi-vernetzt-sich-mit-ampeln-in-duesseldorf-12516>Audi</a> provides a GLOSA traffic assistant for their cars in selected cities (i.a. Ingolstadt, Duesseldorf, and New York (US))</li><li>the <a href=https://www.hamburg.de/bvm/priobike/>PrioBike</a> project in Hamburg includes the <a href=https://output-dd.de/blog/project-post/priobike-schneller-sicherer-und-komfortabler-rad-fahren-mit-intelligenter-datenvernetzung/>PrioBike app</a> as well as the <a href=https://www.hamburg.de/bvm/medien/16759002/2022-12-09-bvm-pilotprojekt/>PrioBike-Säule</a> (see photo below; a fixed post comprised of a sensor and display to show speed advice to cyclists passing by).<br>The PrioBike app is developed by the <a href=https://tu-dresden.de/bu/verkehr/vis/vpa/forschung/Individualverkehr/priobike>TU Dresden</a> and is currently (06/23) in closed beta (unfortunately, my registration mail has not been answered yet, however, an <a href=https://fragdenstaat.de/anfrage/priobike-hh/#nachricht-802863>official statement confirms a planned release later in 2023</a>).<br>The fixed post has been developed together with the company <a href=https://www.yunextraffic.com/bicycle-totem-hamburg/>yunex traffic</a>.</li></ul><p>Unfortunately, currently (06/2023) none of the app solutions is publically available in Hamburg.</p><p>One &ldquo;PrioBike-Säule&rdquo; has been installed close to the Hamburg-Dammtor train station, and judging from limited own experience it seems to work pretty well!<br>(3 out of 4 times it actually showed a fully correct recommendation to catch the next green traffic-light. Sadly, it&rsquo;s not part of my regular cycling routes.)</p><p><img loading=lazy src=img/prio_bike_saeule.jpg alt=prio_bike_saeule></p><h2 id=available-traffic-lights-data-in-hamburg>Available traffic-lights data in Hamburg<a hidden class=anchor aria-hidden=true href=#available-traffic-lights-data-in-hamburg>#</a></h2><p>The <a href=https://geoportal-hamburg.de/geo-online/>geo-portal</a> is an interactive map which can visualize some of the data made available by the city of Hamburg.</p><p>The screenshot below shows real-time traffic-light data of the intersection Fruchtallee / Doormannsweg:</p><p><img loading=lazy src=./img/geoportal_primary_signal.jpg alt=geo-portal-primary-signal></p><p>Colors indicate the current signal of traffic-lights of different lanes.</p><p>Corresponding data is provided for about 800 of 1770 traffic-lights in Hamburg:</p><p><img loading=lazy src=img/tlf_2_0.jpg alt=tlf-2-0></p><p>The data is made available on <a href=https://tld.iot.hamburg.de/v1.1>https://tld.iot.hamburg.de/v1.1</a> via the standard <a href=https://www.ogc.org/standard/sensorthings/>OGC SensorThings API</a> which is described in detail e.g. <a href=https://daten-hamburg.de/tlf_public/TLD_UsageGuide_V1.1.pdf>here</a> (usage guide).<br><a href=https://www.researchgate.net/publication/349105749_Urban_Data_Platform_Hamburg_Integration_von_Echtzeit_IoT-Daten_mittels_SensorThings_API>This paper</a> gives an excellent overview on the system architecture and underlying infrastructure.</p><p>The map below shows a part of the route I used to cycle to work as well as markers for all traffic-lights for which real-time data is currently available:</p><p><img loading=lazy src=img/route-traffic-lights.jpg alt=route-traffic-lights></p><p>Overall, 13 out of 21 traffic-lights on the route provide real-time data (some are currently disabled due to ongoing construction work, and some may just be too small to be prioritized when planning corresponding IoT equipment. Nevertheless, having speed recommendations for almost two thirds of the encountered traffic-lights could already be a nice thing.)</p><p>To give an impression of provided traffic-light real-time data, the following <a href=https://github.com/bokeh/bokeh>bokeh</a>-chart shows some historical data for the relevant primary signal (south -> north) of the above-mentioned intersection Fruchtallee / Doormannsweg (the most westward on the route, with ID 813_19, Datastream-ID 50850), on a typical morning (Friday, 19.05.2023, 6:00-8:00 UTC):</p><p><a href=img/chart/fra_doo_19052023_08_10.html><img loading=lazy src=img/fra_doo_19052023_08_10.png alt=traffic-light-phase-chart>
</a>(<a href=img/chart/fra_doo_19052023_08_10.html>> interactive chart</a>)</p><p>The y-axis shows the duration of a phase over time (x-axis).
Blue indicates the length of complete cycles (red-to-red), and is calculated from the sum of the durations of the different phases, drawn in their corresponding colors. Dashed lines indicate average values over the time-period (arithmetic mean).</p><p>On average, a complete cycle took about 90s and the traffic-light showed red about 63s, green for about 23s, and the transitions (amber / red-amber) only account for 3s and 1s respectively.<br>That makes sense, given that the analyzed traffic-light is pointing towards the lanes going from south to north, while the majority of (car-)traffic at that time can be expected to go from west to east towards the city center.</p><p>The observations show a number of larger deviations from the mean, with green phases being almost twice as long as normal (over 40s, at 06:30 and 07:20), followed by accordingly shorter red phases (only slightly longer than 40s).<br>These deviations may be explained by a dynamic traffic-lights control system, which may extend certain phase durations e.g. to account for bus signal requests (&ldquo;bus priorization&rdquo;), or when detecting extraordinarily high volumes of car traffic going into a specific direction.</p><p>According to a small sample of own observations, recent data is online available via the API in about 1-2s after a signal phase change.</p><p>In addition to the described real-time traffic-light data for car signals, the API also provides further information e.g. on car detectors, bus signal requests, pedestrian signals, and pedestrian signal requests.</p><h2 id=proof-of-concept-a-simple-glosa-web-app>Proof-of-Concept: A simple GLOSA web-app<a hidden class=anchor aria-hidden=true href=#proof-of-concept-a-simple-glosa-web-app>#</a></h2><p>Given quality and quantity of the available data, it does not seem impossible to imagine using it to forecast relevant future signal-phase changes and to calculate reasonable movement speeds from that information.</p><p>Below, a small application is sketched which allows a mobile web-client to request speed recommendations:</p><p><a href=img/components.drawio.png><img loading=lazy src=img/components.drawio.png alt=components></a></p><p>The main flow of information looks as follows:</p><ol><li>a client requests a speed-advice, submitting its current location, movement speed, and trip-id</li><li>based on the trip-id the server can lookup the predefined route and determine the next upcoming traffic-light</li><li>the latest signal-phase change times can be queried from the traffic-lights-data API (encapsulated by a locally running proxy-service)</li><li>based on the received observations, a forecast of future phase changes can be created (also outsourced to a dedicated service)</li><li>the forecast is used to determine the movement speed necessary to catch the next reachable green phase and that information is returned to the client</li><li>whenever the client location updates, a new GLOSA-request is sent (see step <em>1.</em>, limited to at most 1 request per second)</li></ol><p>For the proof-of-concept, the initial route configuration requires some manual effort for importing a defined route (in form of a .gpx file), and for identifying relevant traffic-lights (IDs) with help of the <a href=https://geoportal-hamburg.de/geo-online/>geo-portal</a>.</p><p>The next screenshot shows a minimal web UI which provides information about the current location of the device, the next traffic-light (currently showing red), as well as the speed recomendation (<em>&ldquo;slow down, its not getting green anytime soon..&rdquo;</em>):</p><p><img loading=lazy src=img/run_tour_log_red_too_fast.png alt=too_fast_still_red></p><p>A couple of seconds later, the signal switched to green, and the current speed is sufficient to catch the phase:</p><p><img loading=lazy src=img/run_tour_keep_to_catch_green.png alt=keep_speed_to_catch_green></p><h3 id=gps-independent-testing>GPS-independent testing<a hidden class=anchor aria-hidden=true href=#gps-independent-testing>#</a></h3><p>To facilitate manual testing without being reliant on actual GPS signals, the UI allows for the simulation of movements by dragging the user marker on the map:</p><video style=width:100% autoplay loop controls src=img/simulated_movement.mp4 type=video/mp4>
There should have been a video here but your browser does not seem
to support it.</video><p>For manual testing, the current speed and the accuracy are set to 20 km/h and 10m.</p><h3 id=used-technologies>Used technologies<a hidden class=anchor aria-hidden=true href=#used-technologies>#</a></h3><p>The client is built with React <a href=https://github.com/mui/material-ui>Material UI components</a>, <a href=https://github.com/remix-run/react-router>react-router</a>, <a href=https://github.com/Leaflet/Leaflet>Leaflet</a> for map display and interaction (via <a href=https://github.com/PaulLeCam/react-leaflet>react-leaflet</a>), and the browser <a href=https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API>Geolocation API</a> (consent and secure context required).<br>Since the Geolocation API does not work in the background a <a href=https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API>wakelock</a> can be requested.</p><p>At the server-side, <a href=https://github.com/nginx/nginx>nginx</a> provides basic authentication, ssl-termination, serves static frontend files, and forwards <em>/api</em>-requests.<br>A &ldquo;main backend service&rdquo; is used for central calculations and the &ldquo;orchestration&rdquo; of auxiliary services, built with <a href=https://github.com/spring-projects/spring-boot>Spring Boot</a> (which recently released the amazing support for compiling to a native-image, even though some <a href=https://stackoverflow.com/q/75096690/13156126>stumbling blocks</a> seem to remain).<br>Access to the latest traffic-light data is implemented using <a href=https://github.com/expressjs/express>express</a> running on <a href=https://github.com/nodejs/node>node.js</a>.<br>Future phase change times are forecasted based on the naive expectation of average-length phases, implemented in Python with <a href=https://github.com/pandas-dev/pandas>pandas</a> and exposed via <a href=https://github.com/pallets/flask>flask</a>.</p><p>For simple testing during development, the public <a href=https://github.com/localtunnel/localtunnel>localtunnel</a> service can be used.
This way, a server running at home can be accessed e.g. via mobile network (although they recently had to add some <a href=https://github.com/localtunnel/localtunnel/issues/598>annoying password inquiry</a> on their consent page).</p><p>The repository is available <a href=https://github.com/fladdimir/radapp>on github</a>.</p><h3 id=gps-accuracy-and-route-snapping>GPS accuracy and &ldquo;route snapping&rdquo;<a hidden class=anchor aria-hidden=true href=#gps-accuracy-and-route-snapping>#</a></h3><p>One of the interesting aspects relates to the fact that the position the client detects is always somehow offset from the predefined route, be it due to measurement inaccuracies (commonly up to a couple of meters when using GPS), or inaccurate route definitions.</p><p>Consider the following part of a piece-wise linear route <em>R1-R4</em> and the corresponding measurement <em>L</em>:</p><p><img loading=lazy src=img/route_snap.drawio.png alt=route-snap></p><p><em>L</em> indicates the current location sent by the client device, moving along the predefined route <em>R1-R2-R3-R4</em>.
To give a speed recommendation, the next traffic-light (<em>TL1</em> at <em>R4</em>) needs to be identified, and the correct distance along the given route must be calculated.<br>To determine the current location <em>on the route</em>, potential &ldquo;snap locations&rdquo; (<em>SL1=R1</em>, <em>SL2</em>, <em>SL3</em>) are evaluated by calculating the distance to the closest point on each segment (<em>SL2</em> in the example above).
The performed &ldquo;route snapping&rdquo; of the sent location is similar to (although simpler than) what some maps APIs offer, e.g. OSRMs <a href=https://project-osrm.org/docs/v5.5.1/api/#match-service>match service</a>.<br>To speed up the calculation, each segment is assumed to be linear, so that the <a href=https://github.com/locationtech/jts>JTS Topology Suite</a> Java library&rsquo;s <code>DistanceOp</code> can be used (with converted Mercator-coordinates as a fast simplification).</p><h3 id=performance-considerations>Performance considerations<a hidden class=anchor aria-hidden=true href=#performance-considerations>#</a></h3><p>As the sketched system relies on frequent client-server-communication (~1 request per client per second), performant request handling is of high importance.</p><p>For basic analysis of server-side request processing, the <a href=https://opentelemetry.io/>open telemetry project</a> provides standard tooling which makes it easy to gather tracing information.
This is especially interesting since a client request causes multiple requests to different backend services (database, traffic-lights data API, forecasting service).</p><p>Instrumentation support for automatic trace collection and forwarding to a tracing analysis backend are available for many popular languages / frameworks.
For the main Java service, the <a href=https://github.com/open-telemetry/opentelemetry-java-instrumentation>Java instrumentation agent</a> is used, which injects bytecode so that tracing information is automatically collected for popular frameworks / libraries without any code changes.
Similar auto-instrumentation functionality is available for the <a href=https://opentelemetry.io/docs/instrumentation/js/getting-started/nodejs/>node.js</a> based traffic-lights data API proxy service, and for the <a href=https://opentelemetry.io/docs/instrumentation/python/automatic/agent-config/>Python</a>-based forecast-service.</p><p>The following screenshot shows the processing of a single GLOSA-request:</p><p><a href=img/trace_without_api_proxy_cache.png><img loading=lazy src=img/trace_without_api_proxy_cache.png alt=trace_without_api_proxy_cache></a></p><p>The complete POST to the main backend (<em>locationtracking-0.0.1-SNAPSHOT</em>) takes 105ms to complete, starting with some database accesses (first ~10ms),
followed by a long-running 69ms call to the traffic-lights data API proxy service (<em>tld_api</em>),
and a 14ms call to the forecasting service (<em>tld_forecast</em>).
As we can see, the main share of the overall request processing time is caused by the call to the external traffic-lights data API (68ms), out of which creating the TCP connection and completing the TLS handshake alone require 39ms.</p><p>To improve performance and efficiency of the external data API access, we can use a second feature of the sensorthings API.
Apart from the normal HTTP-API to access historical data of traffic-light signal phase changes, a (websocket-based) MQTT-API allows to subscribe to new updates of specific traffic-lights.
This way, we can extend the functionality of our API proxy service as follows:</p><p><a href=img/api_proxy_cache.drawio.png><img loading=lazy src=img/api_proxy_cache.drawio.png alt=api_proxy_cache></a></p><ol><li>an initial request of the last N signal phase change timestamps causes a regular HTTP request to the external API to fetch the required observations (which are then returned to the client)</li><li>furthermore, the received data is cached, and an MQTT-subscription for future updates is created</li><li>each received update is used to update the cache (evicting the oldest entry)</li><li>each following client-request for the same traffic-light data can now <em>immediately</em> be answered with locally cached data, without causing any external API request</li><li>after a configurable time without any client requests for data of a specific traffic-light (e.g. 60s), its subscription is canceled and its cache is cleared (a following client request is again causing an initial external request (<em>1.</em>))</li></ol><p>The following screenshot shows the processing of a second client request for the same traffic-light data:</p><p><a href=img/trace_with_api_proxy_cache.png><img loading=lazy src=img/trace_with_api_proxy_cache.png alt=trace_with_api_proxy_cache></a></p><p>As we can see, the request to the <em>tld_api</em> is processed within 3ms, without any external call.</p><p>Assuming that data is requested over the last 1km when approaching a traffic-light, going with 20km/h (3 min travel time), and a frequency of 1 request per second, this means that 180 client requests only cause 1 initial external request and 179 subsequent requests are answered from the cache which is updated by push notifications received via MQTT.
Consequently, the average request processing time for clients can be reduced by more than 50% (68/105ms), and the load for the external API server can be drastically reduced (even more when assuming multiple clients request the same traffic-light data).<br>As a further optimization, a server-push technology may be used to avoid polling and to allow for immediate client-notifications on the arrival of new data which causes changes to the last pushed recommendation.</p><p>As a disadvantage, the API proxy service now occupies a long-running MQTT-subscription / web-socket connection to the external API server (which should not cause much performance problems, as modern web-servers / MQTT brokers can be expected to <a href=https://iot.stackexchange.com/a/2661>easily handle large numbers of concurrent of connections</a>, even on commodity hardware).
Additionally, a subscription is kept alive some time after the last client request occured (as we cannot know whether there will be more), so that a couple of updates can be expected to be received unnecessarily - however, that disadvantage should be more than counterbalanced by the amount of saved external requests.</p><p>Apart from the external request handling, further optimization possibilities include database access and calculations at the stateless main backend service.
Instead of loading the predefined route from the database on each client request, corresponding accesses can also be cached, e.g. using <a href=https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#io.caching>Springs built-in caching capabilities</a>.
As there is currently no way to modify predefined routes, their immutability avoids the need for cache invalidation.
Even though there were no detailed measurements, it seems that a couple of milliseconds of request processing time may be saved this way.</p><p>To reduce the calculation effort of the &ldquo;route snapping&rdquo;, the index of the last reached route-segment is submitted back to the client as part of the response, so that this information can be included into a following request.
This way, the number of checked route-segments can be limited, based on the assumption that a client is not expected to move backwards on a route.
Additionally, checking further upcoming route-segments can be aborted once the closest distance to the current location stops to decrease (or does increase over a threshold), so that checking all upcoming route-segments can be avoided (at the expense of possibly missing an even closer segment).
Other optimizations may include reducing the number of segments on a route by combining adjacent segments with (almost) identical direction into a single segment.<br>While the described calculation optimizations may be relevant for longer routes with more segments (i.a. GPS waypoints), there was no measurable difference on the test route when reducing from 522 to 310 waypoints.</p><h3 id=experimental-evaluation>Experimental evaluation<a hidden class=anchor aria-hidden=true href=#experimental-evaluation>#</a></h3><p>To be able to quantify the effects of using the GLOSA app, the geolocation and speed data sent with each request is persisted for analysis.</p><p>The following chart shows the speed profile of a bike ride to work <em>without</em> following the GLOSA speed recommendations:</p><p><a href=img/tour_14156.gif><img loading=lazy src=img/tour_14156.gif alt=tour_14156></a></p><p>The trip had a duration of 00:32:16, and during this time 1,937 samples were collected (almost exactly one GPS update per second).<br>The theoretical distance measured on a map is 10.7 km, the total sum of the distances between all sampled locations is 11.1 km (slightly longer, probably due to GPS inaccuracies and seemingly &ldquo;less straight&rdquo; movements).<br>Given the duration and (theoretical) distance of the trip, an average speed of 5.53 m/s (19.90 km/h) can be calculated.
This is close to the average speed calculated from the 1,937 speed samples (5.38 m/s), so the measurements seem to be quite accurate.<br>The maximum measured speed was 9.30 m/s (33.47 km/h), the share of samples with a measured speed below 1 km/h (likely stops) was 10.8%.</p><p>The next screenshot shows a trip when trying to follow the GLOSA recommendations:</p><p><a href=img/tour_14164.png><img loading=lazy src=img/tour_14164.png alt=tour_14164></a></p><p>To my disappointment, the share of speed measurements below 1 km/h is still 9.2% - a difference of 1.6 percentage points which may not be interpreted to be of any significance.<br>Obviously, any serious evaluation should be based on a larger number of trips.
Furthermore, the experiment itself was probably also negatively influenced by existing personal experience on the common phase lengths.
(Infact, some traffic lights along the route are already quite well-known, so that no external GLOSA recommendation is needed.
Any serious evaluation should of course be performed on routes which are unknown to the testers.)</p><p>While I did not analyse any more specific data, it seems that the effect of using the GLOSA app is negatively influenced by:</p><ul><li>bad traffic light data for some traffic lights (the &ldquo;real-time&rdquo; data is so old that no meaningful predications can be made)</li><li>badly correlated traffic lights (no matter how slow/quick you try to go, between some traffic lights stops are almost inevitable; the phases seem to be optimized for a limited number of cars driving 50 km/h)</li><li>&ldquo;Bedarfsampeln&rdquo; (one traffic light on the route only switches to green upon manual triggering, thus also causing unavoidable stops)</li><li>bad predictions (forecasts purely based on historical data tend to be rather inaccurate, given the dynamic traffic control with adaptive phase lengths)</li></ul><p>Especially the last point causes a particularly frustrating experience in case a green phase could actually have easily been catched when <em>not</em> following a recommendation.</p><hr><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>While digging into the topic, it was quite surprising how and what data is made publically available by the Urban Data Platform of Hamburg.
It&rsquo;s good to see the municipality investing into the digitalization of the traffic-light infrastructure, and also into an IT infrastructure which may make large-scale applications possible.</p><p>Concerning GLOSA applications, the practical benefit really depends on the decisive details - predicting the correct phase change times down to the second is a crucial aspect which seems quite hard to get right in this dynamic environment.
Nevertheless, I am looking forward to the PrioBike app and may give it a try after its publically released (hopefully open-source).</p><h3 id=potential-extensions-and-improvements>Potential extensions and improvements<a hidden class=anchor aria-hidden=true href=#potential-extensions-and-improvements>#</a></h3><p>Based on the sketched proof-of-concept, numerous improvements are imaginable.</p><p>Starting with the annoying manual setup step to define routes and to identify relevant traffic-light signal head IDs, the identification step could be automated as shown by the PrioBike-app developers from the TU Dresden in their <a href=https://github.com/priobike/priobike-sg-selector>selector implementation</a>.</p><p>A main challenge relates to the prediction of future signal phase changes, which could e.g. be extended by incorporating already available data such as bus signal requests.</p><p>Another potential for improvement relates to recommendation algorithms, which could e.g. include information on current/past riding speeds, as well as multiple upcoming traffic-lights (maybe the traffic-light right after the next one will be missed anyway).</p><p>Finally - to generally improve the cycling experience and the quality of life in the city as a whole - other measures like optimizing traffic-light controls towards an average speed of 20-25 km/h, as well as simply extending the cycling lanes can obviously be expected to have a much greater impact than any GLOSA application.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://fladdimir.github.io/tags/java/>Java</a></li><li><a href=https://fladdimir.github.io/tags/spring/>Spring</a></li><li><a href=https://fladdimir.github.io/tags/react/>React</a></li><li><a href=https://fladdimir.github.io/tags/typescript/>TypeScript</a></li><li><a href=https://fladdimir.github.io/tags/leaflet.js/>Leaflet.js</a></li><li><a href=https://fladdimir.github.io/tags/tracing/>Tracing</a></li><li><a href=https://fladdimir.github.io/tags/mqtt/>MQTT</a></li><li><a href=https://fladdimir.github.io/tags/nodejs/>NodeJS</a></li><li><a href=https://fladdimir.github.io/tags/ogc-sensorthings-api/>OGC SensorThings API</a></li></ul><nav class=paginav><a class=next href=https://fladdimir.github.io/post/testing-legacy-code/><span class=title>Next »</span><br><span>Testing Legacy Software</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://fladdimir.github.io/>wh</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>