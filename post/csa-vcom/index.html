<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Logistics Process Models for Automated Integration Testing | WH</title><meta name=keywords content="Python,SimPy,Continuous Integration,Django,Angular,Leaflet.js,Slides"><meta name=description content="Continuous Integration and Virtual Commissioning of Logistics Software"><meta name=author content><link rel=canonical href=https://fladdimir.github.io/post/csa-vcom/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://fladdimir.github.io/icon.png><link rel=icon type=image/png sizes=16x16 href=https://fladdimir.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://fladdimir.github.io/icon.png><link rel=apple-touch-icon href=https://fladdimir.github.io/apple-touch-icon.png><link rel=mask-icon href=https://fladdimir.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script data-goatcounter=https://fmghio.goatcounter.com/count async src=//gc.zgo.at/count.js></script><meta property="og:title" content="Logistics Process Models for Automated Integration Testing"><meta property="og:description" content="Continuous Integration and Virtual Commissioning of Logistics Software"><meta property="og:type" content="article"><meta property="og:url" content="https://fladdimir.github.io/post/csa-vcom/"><meta property="og:image" content="https://fladdimir.github.io/post/csa-vcom/featured.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-05-24T00:00:00+00:00"><meta property="article:modified_time" content="2020-05-24T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://fladdimir.github.io/post/csa-vcom/featured.png"><meta name=twitter:title content="Logistics Process Models for Automated Integration Testing"><meta name=twitter:description content="Continuous Integration and Virtual Commissioning of Logistics Software"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fladdimir.github.io/post/"},{"@type":"ListItem","position":2,"name":"Logistics Process Models for Automated Integration Testing","item":"https://fladdimir.github.io/post/csa-vcom/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Logistics Process Models for Automated Integration Testing","name":"Logistics Process Models for Automated Integration Testing","description":"Continuous Integration and Virtual Commissioning of Logistics Software","keywords":["Python","SimPy","Continuous Integration","Django","Angular","Leaflet.js","Slides"],"articleBody":"The planning and design of logistics systems - both at supply-chain and intralogistics level - is frequently supported by simulation studies, used for comparing design alternatives, assessing their feasibility, as well as estimating KPIs like lead-time or throughput.\nWhen it comes to the realization phase of logistics systems, major challenges relate to the development of controls and operational IT systems. Given the fact that testing, integration, commissioning (and bug-fixing) of these systems tend to consume a significant chunk of the realization phase, it becomes clear that it is beneficial to test a developed system as early as possible - even before physical construction takes place.\nVirtual Commissioning describes the testing of software against the digital counterpart of a real system, making use of simulation models to emulate real-world interaction.\nThis post will show an example of how the integration of simulation-based testing into today’s agile software development processes can look like, investigating a case-study on order management \u0026 delivery optimization.\nGet the repo from github: https://github.com/fladdimir/csa-vcom\nSlides: https://fladdimir.github.io/presentations/des-based-integration-tests.html\nPaper on researchgate\n1. Scenario \u0026 Scope Remember La Pâtisserie, the small French bakery in Hamburg-Altona, which was experiencing a massive shift of demand towards at-home delivery of their sweet pastries?\nHaving evaluated different options of how to scale their business-model with help of an innovative open-source approach to urban delivery network simulation, the growing network now gets harder and harder to manage, calling for an increased software-based support of the bakery’s daily logistics operations…\n2. Processes \u0026 Requirements To be able to focus on their core-competencies (to conjure up delicious treats, instead of fighting intractably inconsistent spread-sheet data), our bakery decides to go for a web-based logistics planning application.\nThe core processes to be supported are:\nRegistration of customers, and tracking their orders Managing locations of the depots to plan the best-possible deliveries Keeping track of the trucks, delivering goods according to the planned tours The following BPMN-diagram shows the the processes and a simple token-flow animation:\nThere should have been a video here but your browser does not seem to support it. 3. Test First: Simulation Model + Build-Pipeline To make sure that all required processes are adequatly supported by the developed software, our bakery’s software development division opts for a test-driven approach, backed by a build-pipeline which automatically checks all code pushed to the repository.\nBased on the specified business process a Casymda simulation model is generated, ready to emulate the real system, with which the developed software is supposed to work. As processes and scope of the application change, the simulation model is evolved in an agile way.\nGitea and Drone form the basis of the continuous integration infrastructure. As part of a virtual commissioning step, the pipeline spins up the application in a service-container, against which the simulation model runs the test-scenario, emulating interaction and verifying the expected behavior of the software.\nThe pipeline is described by a .drone.yml file. Note that the pipeline could be improved in various ways, e.g. by properly waiting for the app (service) to become available for the simulation-step. A docker-compose.yml allows to start the gitea+drone setup locally (using a single-instance setup, which is not ideal, but sufficient for testing).\n4. Application Design \u0026 Implementation Our bakery’s app is dealing with management of the data of customers, orders, depots, tours, and trucks. Additionally, it is required to support planning the delivery process by calculating efficient tours and assigning them to available trucks.\nThe app adopts a basic 3-layer structure consisting of a browser-based ui, a backend containing the business logic and optimization algorithms, and a persisting database. The graphic below summarizes the setup, including the simulation model which acts as a client in the automated build pipeline:\nThe backend is implemented using Django+Django-Rest-Framework, and relying on Google-OR-Tools for optimization tasks. Tour planning is modeled as a capacitated vehicle routing problem with multiple depots. For an optimal assignment of pending tours to available trucks, OR-Tools offers a minimum-cost-flow solver which is used on a corresponding bi-partite graph.\nTo create the required distance matrices, we can utilize the Open Source Routing Machine, provided as a ready-to-use Docker image (OSRM-in-a-box). OSRM offers a convenient API which is synchronously consumed upon creation of a new customer or depot. Open-street-map data can be downloaded e.g. from https://download.geofabrik.de. The map of Hamburg has a size of ~35 MB and OSRM-preprocessing (car-profile) takes about 30 seconds (i5 dual-core notebook processor).\nSQLite provides a simple database solution, however, Django makes it easy to switch to a client/server RDBMS like Postgres or MariaDB.\nThe basic frontend is built with Angular, Material, and Leaflet.js (easy to integrate thanks to ngx-leaflet).\n5. Result The screencast below shows the workflow from a users perspective. It comprises registering a new customer, issuing an order, planning tours, assignment to a truck, and tracking deliveries as the tour proceeds:\nThere should have been a video here but your browser does not seem to support it. The shown process matches the one executed by the simulation model in the virtual commissioning pipeline build step, ensuring stable functionality for every version of the software:\nExtensive and automated integration testing with simulation models can help to enable and sustain software quality, particularly in the context of process-centric logistics applications. As we’ve seen, today’s software development tools and standards allow for an efficient integration of simulation techniques \u0026 virtual commissioning approaches into the development process.\n","wordCount":"894","inLanguage":"en","datePublished":"2020-05-24T00:00:00Z","dateModified":"2020-05-24T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://fladdimir.github.io/post/csa-vcom/"},"publisher":{"@type":"Organization","name":"WH","logo":{"@type":"ImageObject","url":"https://fladdimir.github.io/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fladdimir.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://fladdimir.github.io/tags/ title=/tags><span>/tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fladdimir.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://fladdimir.github.io/post/>Posts</a></div><h1 class=post-title>Logistics Process Models for Automated Integration Testing</h1><div class=post-meta><span title='2020-05-24 00:00:00 +0000 UTC'>May 24, 2020</span>&nbsp;·&nbsp;5 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-scenario--scope>1. Scenario & Scope</a></li><li><a href=#2-processes--requirements>2. Processes & Requirements</a></li><li><a href=#3-test-first-simulation-model--build-pipeline>3. Test First: Simulation Model + Build-Pipeline</a></li><li><a href=#4-application-design--implementation>4. Application Design & Implementation</a></li><li><a href=#5-result>5. Result</a></li></ul></nav></div></details></div><div class=post-content><p>The planning and design of logistics systems - both at supply-chain and intralogistics level - is frequently supported by simulation studies, used for comparing design alternatives, assessing their feasibility, as well as estimating KPIs like lead-time or throughput.</p><p>When it comes to the realization phase of logistics systems, major challenges relate to the development of controls and operational IT systems.
Given the fact that testing, integration, commissioning (and bug-fixing) of these systems tend to consume a significant chunk of the realization phase, it becomes clear that it is beneficial to test a developed system as early as possible - even before physical construction takes place.<br><a href=https://www.sciencedirect.com/science/article/pii/S2212827119305839><em>Virtual Commissioning</em></a> describes the testing of software against the digital counterpart of a real system, making use of <em>simulation</em> models to <em>emulate</em> real-world interaction.</p><p>This post will show an example of how the integration of simulation-based testing into today&rsquo;s agile software development processes can look like, investigating a case-study on order management & delivery optimization.</p><hr><blockquote><p>Get the repo from github: <a href=https://github.com/fladdimir/csa-vcom>https://github.com/fladdimir/csa-vcom</a></p><p>Slides: <a href=https://fladdimir.github.io/presentations/des-based-integration-tests.html>https://fladdimir.github.io/presentations/des-based-integration-tests.html</a></p><p>Paper <a href=https://www.researchgate.net/publication/358822928_From_Logistics_Process_Models_to_Automated_Integration_Testing_Proof-of-Concept_Using_Open-Source_Simulation_Software>on researchgate</a></p></blockquote><hr><h2 id=1-scenario--scope>1. Scenario & Scope<a hidden class=anchor aria-hidden=true href=#1-scenario--scope>#</a></h2><p>Remember <a href=https://www.die-patisserie.de/><em>La Pâtisserie</em></a>, the small French bakery in Hamburg-Altona, which was experiencing <a href=../csa-streetmap/>a massive shift of demand towards at-home delivery</a> of their sweet pastries?</p><p>Having evaluated different options of how to scale their business-model with help of an innovative open-source approach to urban delivery network simulation, the growing network now gets harder and harder to manage, calling for an increased software-based support of the bakery&rsquo;s daily logistics operations&mldr;</p><h2 id=2-processes--requirements>2. Processes & Requirements<a hidden class=anchor aria-hidden=true href=#2-processes--requirements>#</a></h2><p>To be able to focus on their core-competencies (to conjure up delicious treats, instead of fighting intractably inconsistent spread-sheet data), our bakery decides to go for a web-based logistics planning application.<br>The core processes to be supported are:</p><ul><li>Registration of customers, and tracking their orders</li><li>Managing locations of the depots to plan the best-possible deliveries</li><li>Keeping track of the trucks, delivering goods according to the planned tours</li></ul><p>The following BPMN-diagram shows the the processes and a simple token-flow animation:</p><video style=width:100% autoplay loop controls src=img/bpmn.mp4 type=video/mp4>
There should have been a video here but your browser does not seem
to support it.</video><hr><h2 id=3-test-first-simulation-model--build-pipeline>3. Test First: Simulation Model + Build-Pipeline<a hidden class=anchor aria-hidden=true href=#3-test-first-simulation-model--build-pipeline>#</a></h2><p>To make sure that all required processes are adequatly supported by the developed software, our bakery&rsquo;s software development division opts for a test-driven approach, backed by a build-pipeline which automatically checks all code pushed to the repository.<br>Based on the specified business process a <a href=../casymda>Casymda</a> simulation model is generated, ready to emulate the real system, with which the developed software is supposed to work.
As processes and scope of the application change, the simulation model is evolved in an agile way.</p><p><a href=https://gitea.io/>Gitea</a> and <a href=https://drone.io/>Drone</a> form the basis of the continuous integration infrastructure.
As part of a virtual commissioning step, the pipeline spins up the application in a service-container, against which the simulation model runs the test-scenario, emulating interaction and verifying the expected behavior of the software.</p><p><img loading=lazy src=img/pipeline.png alt=pipeline></p><p>The pipeline is described by a <a href=https://github.com/fladdimir/csa-vcom/blob/github/.drone.yml><em>.drone.yml</em></a> file. Note that the pipeline could be improved in various ways, e.g. by properly waiting for the app (service) to become available for the simulation-step.
A <a href=https://github.com/fladdimir/csa-vcom/blob/github/gitea/docker-compose.yml>docker-compose.yml</a> allows to start the gitea+drone setup locally (using a single-instance setup, which is <a href=https://docs.drone.io/server/provider/gitea/>not ideal</a>, but sufficient for testing).</p><hr><h2 id=4-application-design--implementation>4. Application Design & Implementation<a hidden class=anchor aria-hidden=true href=#4-application-design--implementation>#</a></h2><p>Our bakery&rsquo;s app is dealing with management of the data of customers, orders, depots, tours, and trucks.
Additionally, it is required to support planning the delivery process by calculating efficient tours and assigning them to available trucks.</p><p>The app adopts a basic 3-layer structure consisting of a browser-based ui, a backend containing the business logic and optimization algorithms, and a persisting database.
The graphic below summarizes the setup, including the simulation model which acts as a client in the automated build pipeline:</p><p><img loading=lazy src=img/app_layer.png alt=app-parts-overview></p><p>The backend is implemented using <a href=https://www.djangoproject.com/>Django</a>+<a href=https://www.django-rest-framework.org/>Django-Rest-Framework</a>, and relying on <a href=https://developers.google.com/optimization>Google-OR-Tools</a> for optimization tasks.
Tour planning is modeled as a capacitated vehicle routing problem with multiple depots.
For an optimal assignment of pending tours to available trucks, OR-Tools offers a minimum-cost-flow solver which is used on a corresponding bi-partite graph.</p><p>To create the required distance matrices, we can utilize the <a href=https://github.com/Project-OSRM/osrm-backend>Open Source Routing Machine</a>, provided as a ready-to-use Docker image (<a href=https://hub.docker.com/r/osrm/osrm-backend/>OSRM-in-a-box</a>).
OSRM offers a convenient API which is synchronously consumed upon creation of a new customer or depot.
Open-street-map data can be downloaded e.g. from <a href=https://download.geofabrik.de>https://download.geofabrik.de</a>.
The map of <a href=https://download.geofabrik.de/europe/germany/hamburg.html>Hamburg</a> has a size of ~35 MB and OSRM-preprocessing (car-profile) takes about 30 seconds (i5 dual-core notebook processor).</p><p><a href=https://www.sqlite.org/index.html>SQLite</a> provides a simple database solution, however, Django makes it easy to switch to a client/server RDBMS like <a href=https://docs.djangoproject.com/en/3.0/ref/databases/>Postgres or MariaDB</a>.</p><p>The basic frontend is built with <a href=https://angular.io/>Angular</a>, <a href=https://material.angular.io/>Material</a>, and <a href=https://leafletjs.com/>Leaflet.js</a> (easy to integrate thanks to <a href=https://github.com/Asymmetrik/ngx-leaflet>ngx-leaflet</a>).</p><hr><h2 id=5-result>5. Result<a hidden class=anchor aria-hidden=true href=#5-result>#</a></h2><p>The screencast below shows the workflow from a users perspective. It comprises registering a new customer, issuing an order, planning tours, assignment to a truck, and tracking deliveries as the tour proceeds:</p><video style=width:100% autoplay loop controls src=img/app.mp4 type=video/mp4>
There should have been a video here but your browser does not seem
to support it.</video><p>The shown process matches the one executed by the simulation model in the virtual commissioning pipeline build step, ensuring stable functionality for every version of the software:</p><p><img loading=lazy src=img/drone.png alt=drone></p><p>Extensive and automated integration testing with simulation models can help to enable and sustain software quality, particularly in the context of process-centric logistics applications.
As we&rsquo;ve seen, today&rsquo;s software development tools and standards allow for an efficient integration of simulation techniques & virtual commissioning approaches into the development process.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://fladdimir.github.io/tags/python/>Python</a></li><li><a href=https://fladdimir.github.io/tags/simpy/>SimPy</a></li><li><a href=https://fladdimir.github.io/tags/continuous-integration/>Continuous Integration</a></li><li><a href=https://fladdimir.github.io/tags/django/>Django</a></li><li><a href=https://fladdimir.github.io/tags/angular/>Angular</a></li><li><a href=https://fladdimir.github.io/tags/leaflet.js/>Leaflet.js</a></li><li><a href=https://fladdimir.github.io/tags/slides/>Slides</a></li></ul><nav class=paginav><a class=prev href=https://fladdimir.github.io/post/audio-remote-control/><span class=title>« Prev</span><br><span>Minimal Web-based Remote Control with Python and HTML</span></a>
<a class=next href=https://fladdimir.github.io/post/csa-streetmap/><span class=title>Next »</span><br><span>Urban Logistics Network Simulation in Python</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://fladdimir.github.io/>WH</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>