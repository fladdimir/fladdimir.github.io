<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Block-based Modeling with SimPy - in Java & C# | wh</title>
<meta name=keywords content="Python,SimPy,Java,C#"><meta name=description content="Performance Comparison of Casymda-Ports for Uia-Sim and SimSharp"><meta name=author content><link rel=canonical href=https://fladdimir.github.io/post/csa4j+cs/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://fladdimir.github.io/icon.png><link rel=icon type=image/png sizes=16x16 href=https://fladdimir.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://fladdimir.github.io/icon.png><link rel=apple-touch-icon href=https://fladdimir.github.io/apple-touch-icon.png><link rel=mask-icon href=https://fladdimir.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script data-goatcounter=https://fmghio.goatcounter.com/count async src=//gc.zgo.at/count.js></script><meta property="og:title" content="Block-based Modeling with SimPy - in Java & C#"><meta property="og:description" content="Performance Comparison of Casymda-Ports for Uia-Sim and SimSharp"><meta property="og:type" content="article"><meta property="og:url" content="https://fladdimir.github.io/post/csa4j+cs/"><meta property="og:image" content="https://fladdimir.github.io/post/csa4j+cs/featured.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-12-20T00:00:00+00:00"><meta property="article:modified_time" content="2020-12-20T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://fladdimir.github.io/post/csa4j+cs/featured.png"><meta name=twitter:title content="Block-based Modeling with SimPy - in Java & C#"><meta name=twitter:description content="Performance Comparison of Casymda-Ports for Uia-Sim and SimSharp"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fladdimir.github.io/post/"},{"@type":"ListItem","position":2,"name":"Block-based Modeling with SimPy - in Java \u0026 C#","item":"https://fladdimir.github.io/post/csa4j+cs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Block-based Modeling with SimPy - in Java \u0026 C#","name":"Block-based Modeling with SimPy - in Java \u0026 C#","description":"Performance Comparison of Casymda-Ports for Uia-Sim and SimSharp","keywords":["Python","SimPy","Java","C#"],"articleBody":"When creating Python-based simulation models with Casymda /SimPy, a frequent remark is that Python - being a slow, dynamic, interpreted language - would be a bad choice for this type of endeavour.\nSo could compiled, statically-typed SimPy alternatives make model execution faster, therefore being a better choice for development?\nThis post will have a look at Uia-Sim and SimSharp, two SimPy ports for discrete event simulation in Java and C#. As a proof-of-concept, two small block-based modeling libraries were created, similar to Casymda for SimPy, and their execution speed was compared with help of a simple benchmark model.\nUia-Sim: SimPy for Java Uia-Sim is a recently published Java port of SimPy, published by UIA Java Solutions. Since Java does not provide generators/coroutines out of the box, the creator developed a “yield-like API” to enable blocking and resuming of simulation processes with help of threads.\nBased on Uia-Sim, a Casymda-like library for block-based composition of discrete event simulation models was created as a proof-of-concept. Csa4j implements some of the ideas from Casymda:\na Block as the basic class to compose simulation models is executing processing logic for received entities, and forwarding to successor-blocks can be extended for custom processing logic (e.g. elapsing time, as Delay) Source-blocks spawn entities and initiate their processing Sink-blocks end entity processing and cause removal from the simulation basic animation capabilities can visualize the entity flow between model blocks for debug / presentation As an improvement over Casymda, animation-related behavior and data was properly seperated from the simulation-related behavior of basic blocks, which just provide notifications whenever block-states change or entity movements occur.\nSimilar to Casymda’s debug animation based on Tkinter, corresponding visualizations can be created in Csa4j with JavaFX. While browser-based animation was out of scope for this PoC, the multitude of existing (micro-) web-frameworks for Java would make it easy to provide corresponding functionality. Further missing features which are present in Casymda include the parsing of .bpmn files to generate simulation model classes, the state-tracking of blocks, and tilemap-movements.\nThe project uses a basic gradle setup with Java 14 and JUnit-tests. Coverage info and static code analysis can be obtained with help of jacoco, sonarqube, and a sonarqube gradle plugin. Since Uia-Sim seems to be not yet available via maven-central, this dependency can be built locally and primarily be retrieved via a local maven repository. VSCode and its Java extension pack provide a great development experience.\nSimSharp: SimPy for .NET SimSharp is a .NET port of SimPy which is developed by the research group “Heuristic and Evolutionary Algorithms Laboratory” (HEAL) from Austria (also known for the HeuristicLab optimization framework). Similar to SimPy (and different to Uia-Sim), SimSharp is using iterators for resumable simulation-processes.\nCreated for this PoC, the Csa4cs-library provides the same features as “Csa4j” (described in the previous section), including a simple canvas animation based on skiasharp and gtksharp.\nThe project is based on the .NET 5.0 SDK, using the XUnit test framework. Similar to the Java project, coverage info and static code analysis can be obtained conveniently with sonarqube (even though the scan step requires a bit more setup effort compared with the gradle plugin usage in Java). Thanks to its C# extension, VSCode can offer great development support.\nPerformance Comparison To evaluate the execution speed of the simulation libraries, the same model was implemented using Casymda/SimPy, Csa4j/Uia-Sim, and Csa4cs/SimSharp. Additionally, the SimPy-model was executed using CPython and PyPy. Identical assertions on the results of the simulations verify the correctness of the model implementations.\nThe benchmark model is made of typically used, basic processing blocks and is shown below.\nOne source produces entities with a given inter-arrival-time and forwards them to a gateway, which alternatingly chooses either a delay-block with infinite capacity (parallel processing), or a buffer which is placed before a delay-block with capacity 1 (sequential processing). A second gateway joins both entity flows.\nDepending on the inter-arrival-time, 2 main scenarios can be simulated:\ninter-arrival-time \u003e processing time not causing any queues or actually parallel processing, representing a plain processing of entities with a short event queue inter-arrival-time \u003c processing time leading to a queue before the sequential processing (up to n/2 entities waiting), and a simultaneous processing of the other n/2 entities Different experiments simulate the processing of 10 to 200_000 entities and were carried out on an Ubuntu notebook with i5 processor.\nThe diagram below shows the execution time of the simulation runs for the first scenario where no queing occurs, depending on the number of created entities:\nAs we can see - and as one might expect - the execution time linearly grows with the number of processed entities on all platforms. Interestingly, the Java model (red) is considerably slower than the Python and the C# versions, so that the longer experiments were omitted. This performance drawback could be explained by fact that one os-thread is created per entity-process, combined with a high computational overhead of threads compared to generator/iterable-based coroutine-objects. Even for short runs, the PyPy JIT compiler (orange) can reach an impressive speed-up compared to CPython (blue). The .NET model outperforms even PyPy by a factor of ~5.\nThe second chart shows the queuing scenario, with up to one half of the entities waiting for a shared resource, and the other half being simultaneously processed:\nAs before, the longer runs of the Java model were omitted due to their duration. While CPython and .NET show an again seemingly linear growth, the exponential development of the PyPy execution time reveals a rather surprising slow-down in the long run compared to CPython.\nSummary Static typing alone does (surprisingly) not guarantee any execution speed advantage. SimSharp did prove to work great and might definitely be worth further evaluation. The Java-based library should probably not be used when creating many simulated processes (e.g. one process per entity, with many rather short-lived entities as in the sample model). PyPy can provide significant speed-ups over CPython, closing the gap between Python and C# - however, that depends. The shown figures were created from a first, tentative, prelimenary comparison, delivering results which are not even fully comparable (especially due to the omitted features in the Java and C# libraries). Apart from execution speed, the eco-system remains as a strong plus for creating discrete event simulation models with Python.\n","wordCount":"1044","inLanguage":"en","datePublished":"2020-12-20T00:00:00Z","dateModified":"2020-12-20T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://fladdimir.github.io/post/csa4j+cs/"},"publisher":{"@type":"Organization","name":"wh","logo":{"@type":"ImageObject","url":"https://fladdimir.github.io/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fladdimir.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://fladdimir.github.io/tags/ title=/tags><span>/tags</span></a></li><li><a href=https://fladdimir.github.io/search title="/search (Alt + /)" accesskey=/><span>/search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fladdimir.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://fladdimir.github.io/post/>Posts</a></div><h1 class=post-title>Block-based Modeling with SimPy - in Java & C#</h1><div class=post-meta><span title='2020-12-20 00:00:00 +0000 UTC'>December 20, 2020</span>&nbsp;·&nbsp;5 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#uia-sim-simpy-for-java>Uia-Sim: SimPy for Java</a></li><li><a href=#simsharp-simpy-for-net>SimSharp: SimPy for .NET</a></li><li><a href=#performance-comparison>Performance Comparison</a></li><li><a href=#summary>Summary</a></li></ul></nav></div></details></div><div class=post-content><p>When creating Python-based simulation models with <a href=../casymda/>Casymda</a> /<a href=https://gitlab.com/team-simpy/simpy>SimPy</a>, a frequent remark is that Python - being a slow, dynamic, interpreted language - would be a bad choice for this type of endeavour.</p><p>So could compiled, statically-typed SimPy alternatives make model execution faster, therefore being a better choice for development?</p><p>This post will have a look at <a href=https://github.com/uia4j/uia-sim>Uia-Sim</a> and <a href=https://github.com/heal-research/SimSharp>SimSharp</a>, two SimPy ports for discrete event simulation in Java and C#.
As a proof-of-concept, two small block-based modeling libraries were created, similar to Casymda for SimPy, and their execution speed was compared with help of a simple benchmark model.</p><h2 id=uia-sim-simpy-for-java>Uia-Sim: SimPy for Java<a hidden class=anchor aria-hidden=true href=#uia-sim-simpy-for-java>#</a></h2><p><a href=https://github.com/uia4j/uia-sim>Uia-Sim</a> is a recently published Java port of SimPy, published by <a href=https://github.com/uia4j>UIA Java Solutions</a>. Since Java does not provide generators/coroutines out of the box, the creator developed a &ldquo;yield-like API&rdquo; to enable blocking and resuming of simulation processes with help of threads.</p><p>Based on Uia-Sim, a Casymda-like library for block-based composition of discrete event simulation models was created as a proof-of-concept.
<a href=https://github.com/fladdimir/csa4j>Csa4j</a> implements some of the ideas from Casymda:</p><ul><li>a <code>Block</code> as the basic class to compose simulation models<ul><li>is executing processing logic for received entities, and forwarding to successor-blocks</li><li>can be extended for custom processing logic (e.g. elapsing time, as <code>Delay</code>)</li></ul></li><li><code>Source</code>-blocks spawn entities and initiate their processing</li><li><code>Sink</code>-blocks end entity processing and cause removal from the simulation</li><li>basic animation capabilities can visualize the entity flow between model blocks for debug / presentation</li></ul><p>As an improvement over Casymda, animation-related behavior and data was properly seperated from the simulation-related behavior of basic blocks, which just provide notifications whenever block-states change or entity movements occur.<br>Similar to Casymda&rsquo;s debug animation based on Tkinter, corresponding visualizations can be created in Csa4j with JavaFX.
While browser-based animation was out of scope for this PoC, the multitude of existing (micro-) web-frameworks for Java would make it easy to provide corresponding functionality.
Further missing features which are present in Casymda include the parsing of .bpmn files to generate simulation model classes, the state-tracking of blocks, and tilemap-movements.</p><p>The project uses a basic gradle setup with Java 14 and JUnit-tests. Coverage info and static code analysis can be obtained with help of jacoco, sonarqube, and a sonarqube gradle plugin. Since Uia-Sim seems to be not yet available via maven-central, this dependency can be built locally and primarily be retrieved via a local maven repository. VSCode and its Java extension pack provide a great development experience.</p><h2 id=simsharp-simpy-for-net>SimSharp: SimPy for .NET<a hidden class=anchor aria-hidden=true href=#simsharp-simpy-for-net>#</a></h2><p><a href=https://github.com/heal-research/SimSharp>SimSharp</a> is a .NET port of SimPy which is developed by the research group &ldquo;Heuristic and Evolutionary Algorithms Laboratory&rdquo; (HEAL) from Austria (also known for the <a href=https://dev.heuristiclab.com>HeuristicLab</a> optimization framework). Similar to SimPy (and different to Uia-Sim), SimSharp is using iterators for resumable simulation-processes.</p><p>Created for this PoC, the <a href=https://github.com/fladdimir/csa4cs>Csa4cs</a>-library provides the same features as &ldquo;Csa4j&rdquo; (described in the previous section), including a simple canvas animation based on skiasharp and gtksharp.<br>The project is based on the .NET 5.0 SDK, using the XUnit test framework. Similar to the Java project, coverage info and static code analysis can be obtained conveniently with sonarqube (even though the scan step requires a bit more setup effort compared with the gradle plugin usage in Java).
Thanks to its C# extension, VSCode can offer great development support.</p><h2 id=performance-comparison>Performance Comparison<a hidden class=anchor aria-hidden=true href=#performance-comparison>#</a></h2><p>To evaluate the execution speed of the simulation libraries, the same model was implemented using Casymda/SimPy, Csa4j/Uia-Sim, and Csa4cs/SimSharp.
Additionally, the SimPy-model was executed using CPython and PyPy. Identical assertions on the results of the simulations verify the correctness of the model implementations.</p><p>The benchmark model is made of typically used, basic processing blocks and is shown below.<br>One source produces entities with a given inter-arrival-time and forwards them to a gateway, which alternatingly chooses either a delay-block with infinite capacity (parallel processing), or a buffer which is placed before a delay-block with capacity 1 (sequential processing). A second gateway joins both entity flows.</p><p><img loading=lazy src=./img/model.gif alt=animated-process></p><p>Depending on the inter-arrival-time, 2 main scenarios can be simulated:</p><ul><li>inter-arrival-time > processing time<ul><li>not causing any queues or actually parallel processing, representing a plain processing of entities with a short event queue</li></ul></li><li>inter-arrival-time &lt; processing time<ul><li>leading to a queue before the sequential processing (up to n/2 entities waiting), and a simultaneous processing of the other n/2 entities</li></ul></li></ul><p>Different experiments simulate the processing of 10 to 200_000 entities and were carried out on an Ubuntu notebook with i5 processor.</p><p>The diagram below shows the execution time of the simulation runs for the first scenario where no queing occurs, depending on the number of created entities:</p><p><img loading=lazy src=img/iat_10.png alt=chart_iat_10></p><p>As we can see - and as one might expect - the execution time linearly grows with the number of processed entities on all platforms.
Interestingly, the Java model (red) is considerably slower than the Python and the C# versions, so that the longer experiments were omitted.
This performance drawback could be explained by fact that one os-thread is created per entity-process, combined with a high computational overhead of threads compared to generator/iterable-based coroutine-objects.
Even for short runs, the PyPy JIT compiler (orange) can reach an impressive speed-up compared to CPython (blue).
The .NET model outperforms even PyPy by a factor of ~5.</p><p>The second chart shows the queuing scenario, with up to one half of the entities waiting for a shared resource, and the other half being simultaneously processed:</p><p><img loading=lazy src=img/iat_0.png alt=chart_iat_0></p><p>As before, the longer runs of the Java model were omitted due to their duration.
While CPython and .NET show an again seemingly linear growth, the exponential development of the PyPy execution time reveals a rather surprising slow-down in the long run compared to CPython.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><ul><li>Static typing alone does (surprisingly) not guarantee any execution speed advantage.</li><li>SimSharp did prove to work great and might definitely be worth further evaluation.</li><li>The Java-based library should probably not be used when creating many simulated processes (e.g. one process per entity, with many rather short-lived entities as in the sample model).</li><li>PyPy can provide significant speed-ups over CPython, closing the gap between Python and C# - however, that depends.</li></ul><p>The shown figures were created from a first, tentative, prelimenary comparison, delivering results which are not even fully comparable (especially due to the omitted features in the Java and C# libraries). Apart from execution speed, the eco-system remains as a strong plus for creating discrete event simulation models with Python.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://fladdimir.github.io/tags/python/>Python</a></li><li><a href=https://fladdimir.github.io/tags/simpy/>SimPy</a></li><li><a href=https://fladdimir.github.io/tags/java/>Java</a></li><li><a href=https://fladdimir.github.io/tags/c#/>C#</a></li></ul><nav class=paginav><a class=prev href=https://fladdimir.github.io/post/location-sharing/><span class=title>« Prev</span><br><span>Playing around with React, Leaflet, Micronaut, Okta, & Heroku</span>
</a><a class=next href=https://fladdimir.github.io/post/csa-simulation-based-sc-forecast/><span class=title>Next »</span><br><span>Real Time Simulation-based Supply Chain Analytics</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://fladdimir.github.io/>wh</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>