<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wladimir Hofmann | Homepage</title>
    <link>/authors/fladdimir/</link>
      <atom:link href="/authors/fladdimir/index.xml" rel="self" type="application/rss+xml" />
    <description>Wladimir Hofmann | Homepage</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 20 Dec 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>Wladimir Hofmann | Homepage</title>
      <link>/authors/fladdimir/</link>
    </image>
    
    <item>
      <title>Block-based Modeling with SimPy - in Java &amp; C#</title>
      <link>/post/csa4j&#43;cs/</link>
      <pubDate>Sun, 20 Dec 2020 00:00:00 +0000</pubDate>
      <guid>/post/csa4j&#43;cs/</guid>
      <description>&lt;p&gt;When creating Python-based simulation models with 
&lt;a href=&#34;../casymda/&#34;&gt;Casymda&lt;/a&gt; /
&lt;a href=&#34;https://gitlab.com/team-simpy/simpy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SimPy&lt;/a&gt;, a frequent remark is that Python - being a slow, dynamic, interpreted language - would be a bad choice for this type of endeavour.&lt;/p&gt;
&lt;p&gt;So could compiled, statically-typed SimPy alternatives make model execution faster, therefore being a better choice for development?&lt;/p&gt;
&lt;p&gt;This post will have a look at 
&lt;a href=&#34;https://github.com/uia4j/uia-sim&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Uia-Sim&lt;/a&gt; and 
&lt;a href=&#34;https://github.com/heal-research/SimSharp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SimSharp&lt;/a&gt;, two SimPy ports for discrete event simulation in Java and C#.
As a proof-of-concept, two small block-based modeling libraries were created, similar to Casymda for SimPy, and their execution speed was compared with help of a simple benchmark model.&lt;/p&gt;
&lt;h2 id=&#34;uia-sim-simpy-for-java&#34;&gt;Uia-Sim: SimPy for Java&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/uia4j/uia-sim&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Uia-Sim&lt;/a&gt; is a recently published Java port of SimPy, published by 
&lt;a href=&#34;https://github.com/uia4j&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;UIA Java Solutions&lt;/a&gt;. Since Java does not provide generators/coroutines out of the box, the creator developed a &amp;ldquo;yield-like API&amp;rdquo; to enable blocking and resuming of simulation processes with help of threads.&lt;/p&gt;
&lt;p&gt;Based on Uia-Sim, a Casymda-like library for block-based composition of discrete event simulation models was created as a proof-of-concept.

&lt;a href=&#34;https://github.com/fladdimir/csa4j&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Csa4j&lt;/a&gt; implements some of the ideas from Casymda:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a &lt;code&gt;Block&lt;/code&gt; as the basic class to compose simulation models
&lt;ul&gt;
&lt;li&gt;is executing processing logic for received entities, and forwarding to successor-blocks&lt;/li&gt;
&lt;li&gt;can be extended for custom processing logic (e.g. elapsing time, as &lt;code&gt;Delay&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Source&lt;/code&gt;-blocks spawn entities and initiate their processing&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sink&lt;/code&gt;-blocks end entity processing and cause removal from the simulation&lt;/li&gt;
&lt;li&gt;basic animation capabilities can visualize the entity flow between model blocks for debug / presentation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As an improvement over Casymda, animation-related behavior and data was properly seperated from the simulation-related behavior of basic blocks, which just provide notifications whenever block-states change or entity movements occur.&lt;br&gt;
Similar to Casymda&amp;rsquo;s debug animation based on Tkinter, corresponding visualizations can be created in Csa4j with JavaFX.
While browser-based animation was out of scope for this PoC, the multitude of existing (micro-) web-frameworks for Java would make it easy to provide corresponding functionality.
Further missing features which are present in Casymda include the parsing of .bpmn files to generate simulation model classes, the state-tracking of blocks, and tilemap-movements.&lt;/p&gt;
&lt;p&gt;The project uses a basic gradle setup with Java 14 and JUnit-tests. Coverage info and static code analysis can be obtained with help of jacoco, sonarqube, and a sonarqube gradle plugin. Since Uia-Sim seems to be not yet available via maven-central, this dependency can be built locally and primarily be retrieved via a local maven repository. VSCode and its Java extension pack provide a great development experience.&lt;/p&gt;
&lt;h2 id=&#34;simsharp-simpy-for-net&#34;&gt;SimSharp: SimPy for .NET&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/heal-research/SimSharp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SimSharp&lt;/a&gt; is a .NET port of SimPy which is developed by the research group &amp;ldquo;Heuristic and Evolutionary Algorithms Laboratory&amp;rdquo; (HEAL) from Austria (also known for the 
&lt;a href=&#34;https://dev.heuristiclab.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HeuristicLab&lt;/a&gt; optimization framework). Similar to SimPy (and different to Uia-Sim), SimSharp is using iterators for resumable simulation-processes.&lt;/p&gt;
&lt;p&gt;Created for this PoC, the 
&lt;a href=&#34;https://github.com/fladdimir/csa4cs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Csa4cs&lt;/a&gt;-library provides the same features as &amp;ldquo;Csa4j&amp;rdquo; (described in the previous section), including a simple canvas animation based on skiasharp and gtksharp.&lt;br&gt;
The project is based on the .NET 5.0 SDK, using the XUnit test framework. Similar to the Java project, coverage info and static code analysis can be obtained conveniently with sonarqube (even though the scan step requires a bit more setup effort compared with the gradle plugin usage in Java).
Thanks to its C# extension, VSCode can offer great development support.&lt;/p&gt;
&lt;h2 id=&#34;performance-comparison&#34;&gt;Performance Comparison&lt;/h2&gt;
&lt;p&gt;To evaluate the execution speed of the simulation libraries, the same model was implemented using Casymda/SimPy, Csa4j/Uia-Sim, and Csa4cs/SimSharp.
Additionally, the SimPy-model was executed using CPython and PyPy. Identical assertions on the results of the simulations verify the correctness of the model implementations.&lt;/p&gt;
&lt;p&gt;The benchmark model is made of typically used, basic processing blocks and is shown below.&lt;br&gt;
One source produces entities with a given inter-arrival-time and forwards them to a gateway, which alternatingly chooses either a delay-block with infinite capacity (parallel processing), or a buffer which is placed before a delay-block with capacity 1 (sequential processing). A second gateway joins both entity flows.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./img/model.gif&#34; alt=&#34;animated-process&#34;&gt;&lt;/p&gt;
&lt;p&gt;Depending on the inter-arrival-time, 2 main scenarios can be simulated:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inter-arrival-time &amp;gt; processing time
&lt;ul&gt;
&lt;li&gt;not causing any queues or actually parallel processing, representing a plain processing of entities with a short event queue&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;inter-arrival-time &amp;lt; processing time
&lt;ul&gt;
&lt;li&gt;leading to a queue before the sequential processing (up to n/2 entities waiting), and a simultaneous processing of the other n/2 entities&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Different experiments simulate the processing of 10 to 200_000 entities and were carried out on an Ubuntu notebook with i5 processor.&lt;/p&gt;
&lt;p&gt;The diagram below shows the execution time of the simulation runs for the first scenario where no queing occurs, depending on the number of created entities:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;img/iat_10.png&#34; alt=&#34;chart_iat_10&#34;&gt;&lt;/p&gt;
&lt;p&gt;As we can see - and as one might expect - the execution time linearly grows with the number of processed entities on all platforms.
Interestingly, the Java model (red) is considerably slower than the Python and the C# versions, so that the longer experiments were omitted.
This performance drawback could be explained by fact that one os-thread is created per entity-process, combined with a high computational overhead of threads compared to generator/iterable-based coroutine-objects.
Even for short runs, the PyPy JIT compiler (orange) can reach an impressive speed-up compared to CPython (blue).
The .NET model outperforms even PyPy by a factor of ~5.&lt;/p&gt;
&lt;p&gt;The second chart shows the queuing scenario, with up to one half of the entities waiting for a shared resource, and the other half being simultaneously processed:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;img/iat_0.png&#34; alt=&#34;chart_iat_0&#34;&gt;&lt;/p&gt;
&lt;p&gt;As before, the longer runs of the Java model were omitted due to their duration.
While CPython and .NET show an again seemingly linear growth, the exponential development of the PyPy execution time reveals a rather surprising slow-down in the long run compared to CPython.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Static typing alone does (surprisingly) not guarantee any execution speed advantage.&lt;/li&gt;
&lt;li&gt;SimSharp did prove to work great and might definitely be worth further evaluation.&lt;/li&gt;
&lt;li&gt;The Java-based library should probably not be used when creating many simulated processes (e.g. one process per entity, with many rather short-lived entities as in the sample model).&lt;/li&gt;
&lt;li&gt;PyPy can provide significant speed-ups over CPython, closing the gap between Python and C# - however, that depends.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The shown figures were created from a first, tentative, prelimenary comparison, delivering results which are not even fully comparable (especially due to the omitted features in the Java and C# libraries). Apart from execution speed, the eco-system remains as a strong plus for creating discrete event simulation models with Python.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Real Time Simulation-based Supply Chain Analytics</title>
      <link>/post/csa-simulation-based-sc-forecast/</link>
      <pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate>
      <guid>/post/csa-simulation-based-sc-forecast/</guid>
      <description>&lt;p&gt;In his highly interesting, recently published 
&lt;a href=&#34;http://nbn-resolving.de/urn:nbn:de:bvb:29-opus4-145483&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PhD thesis (German)&lt;/a&gt;, Toni Donhauser from the University Erlangen-Nürnberg gives an excellent example on how a production-synchronous digital twin can be used for automated, simulation-based order scheduling in masonry plants.&lt;/p&gt;
&lt;p&gt;As a core feature, the developed simulation allows to initialize the &lt;em&gt;work-in-process&lt;/em&gt; of the manufacturing system to precisely mirror the current state and create accurate short-term forecasts, which serve as a basis for comparing alternatives and optimizing production plans in case of unexpected disruptions.

&lt;a href=&#34;https://www.plm.automation.siemens.com/global/de/products/manufacturing-planning/plant-simulation-throughput-optimization.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tecnomatix Plant Simulation (Siemens)&lt;/a&gt; is used for the implementation of the simulation model.
Manufacturing data is fetched via the built-in OPC-UA interface from an OPC server and via ODBC from an MS Access database.
Simulation runs can be triggered manually by an operator using a management application written in C#.&lt;/p&gt;
&lt;p&gt;Since &lt;em&gt;Plant Simulation&lt;/em&gt; is known for extensive features as well as for extensive licensing fees, this blog post will present an alternative implementation of such a production-synchronous digital twin, based on open-source frameworks and building on easy-to-operate, pay-per-use AWS infrastructure.&lt;/p&gt;
&lt;p&gt;The complete setup can be deployed and tested locally using &lt;em&gt;Docker&lt;/em&gt;, &lt;em&gt;LocalStack&lt;/em&gt; and &lt;em&gt;Terraform&lt;/em&gt; (no AWS account required).&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;Get the repo from github:&lt;br&gt;
&lt;a href=&#34;https://github.com/fladdimir/csa-simulation-based-sc-forecast&#34;&gt;https://github.com/fladdimir/csa-simulation-based-sc-forecast&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;scenario--scope&#34;&gt;Scenario &amp;amp; Scope&lt;/h2&gt;
&lt;p&gt;The chart below shows a fictive and simplified order manufacturing process, serving as a minimal example to illustrate how a digital twin of the system can be implemented.&lt;br&gt;
After being created, orders are received and accepted by the company (&lt;em&gt;&amp;ldquo;ingest&amp;rdquo;&lt;/em&gt;-step), and the order-specific raw material is ordered (&lt;em&gt;&amp;ldquo;order_material&amp;rdquo;&lt;/em&gt;), leaving the order waiting until the corresponding material arrives (&lt;em&gt;&amp;ldquo;wait_for_material&amp;rdquo;&lt;/em&gt;).
When the material is delivered, the order proceeds to a queue (&lt;em&gt;&amp;ldquo;wait_for_sop&amp;rdquo;&lt;/em&gt;), waiting to be processed in a capacity-constrained &lt;em&gt;&amp;ldquo;production&amp;rdquo;&lt;/em&gt;-step, which is only able to process one order at a time.
Eventually, the finished order gets delivered to the customer and leaves the system.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;img/diagram.png&#34; alt=&#34;process-flow&#34;&gt;&lt;/p&gt;
&lt;p&gt;Whenever material for an order is requested, an initial estimated time of arrival (ETA) is assigned.
However, unexpected supplier-specific process deviations or other delivery problems may introduce delays at any point in time, so that ETA-updates are possible during this step.
Since the production step uses a capacity-constrained resource and represents a possible bottleneck of the system, any unplanned under-utilization here may delay every upcoming order and diminish the system throughput (depending on how tight the schedule looks like).
Therefore, it is desirable to be able to quantify the effects of any shift in time as soon as an ETA-update for an order occurs.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;synchronized-digital-twin-concept-and-implementation&#34;&gt;Synchronized Digital Twin: Concept and Implementation&lt;/h2&gt;
&lt;p&gt;The next figure shows a simple event-processing pipeline, able to ingest defined events and to persist the system state (&lt;em&gt;event tracking&lt;/em&gt;), which in turn enables the simulation-based creation of forecasts for expected order completions times and delays (&lt;em&gt;event analytics&lt;/em&gt;).
A simple web-dashboard will be used to visualize the results.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;img/concept.png&#34; alt=&#34;event-processing-pipeline&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;1-publishing-events-of-data-producers&#34;&gt;1. Publishing events of data producers&lt;/h4&gt;
&lt;p&gt;During the processing of an order in the physical system, data producers such as sensors and IoT-devices are capturing information on the progress, i.e. events of state-changes as e.g. start or finish of the production step of an order.
These order updates are published to a defined endpoint where they are collected and processed (2.).
While those events would actually be happening in the physical manufacturing system, a simulation model might be used to create test-data for the digital twin (see the 
&lt;a href=&#34;../csa-vcom/&#34;&gt;post on &lt;em&gt;Virtual Commissioning&lt;/em&gt;&lt;/a&gt; for another example of this use-case for simulation).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./img/icons/kinesis.png&#34; alt=&#34;kinesis&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-capturing-events-with-aws-kinesis&#34;&gt;2. Capturing events with AWS Kinesis&lt;/h4&gt;
&lt;p&gt;
&lt;a href=&#34;https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kinesis&lt;/a&gt; is an AWS service for continuous buffering and real-time processing of streaming data.
A Kinesis &lt;em&gt;stream&lt;/em&gt; decouples data producers and consumers and consists of a configurable number of &lt;em&gt;shards&lt;/em&gt;, each of which is able to ingest up to 1 MB or 1000 records of data per second.
Each record is put into one shard based on it&amp;rsquo;s specified &lt;em&gt;partition key&lt;/em&gt; value, which gets important since in-order processing of records is 
&lt;a href=&#34;https://aws.amazon.com/blogs/compute/new-aws-lambda-scaling-controls-for-kinesis-and-dynamodb-event-sources/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;guaranteed only on partition key level&lt;/a&gt;.&lt;br&gt;
In the described scenario in-order processing becomes critical for ETA-updates of orders, since the message of an expected delay must not be processed before an earlier submitted update.&lt;br&gt;
New records can be put to the stream e.g. using the AWS SDK, which is available for various languages, including Python which is used for the emulated test client.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./img/icons/lambda.png&#34; alt=&#34;lambda&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;3-processing-events-with-aws-lambda&#34;&gt;3. Processing events with AWS Lambda&lt;/h4&gt;
&lt;p&gt;
&lt;a href=&#34;https://aws.amazon.com/lambda/?nc1=h_ls&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lambda&lt;/a&gt; is the function-as-a-service offer of AWS, which allows to run code on-demand, paying for the number of invocations as well as for execution time.
Lambda functions can easily be integrated with other services such as SQS and DynamoDB.
Since AWS provisions the function runtime on-demand, the short cold-start times of NodeJS and Python make them a popular choice for implementing lambdas, while &amp;ldquo;heavier&amp;rdquo; alternatives such as Java are less common (the JVM would need multiple invocations for the JIT-compilation to boost performance).&lt;br&gt;
The lambda implemented for processing order updates is simple and just updates the corresponding item of the affected order in a specified DynamoDB table with data from the event provided as part of the invocation.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./img/icons/dynamodb.png&#34; alt=&#34;dynamodb&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;4-persisting-the-system-state-with-dynamodb&#34;&gt;4. Persisting the system state with DynamoDB&lt;/h4&gt;
&lt;p&gt;
&lt;a href=&#34;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DynamoDB&lt;/a&gt; is used as a fast, flexible and managed NoSQL database.
While this type of database by design lacks some of the amenities of relational databases (such as proper means to enforce referential integrity on the database level, or the availability of sophisticated ORMs and schema management tools), it is fine for our simple use-case which just involves updating single items and basic queries.
DynamoDB requires a hashkey and optionally a partition key, both of which are used in combination to uniquely identify a stored item.
For orders the string id can be used as the hashkey.
A nice feature of DynamoDB is the option to enable &lt;em&gt;streams&lt;/em&gt;, automatically providing information on table-updates. This way, order ETA-updates can trigger new forecasts.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./img/icons/lambda.png&#34; alt=&#34;lambda&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;5-simulating-the-future&#34;&gt;5. Simulating the future&lt;/h4&gt;
&lt;p&gt;AWS allows to use Lambda functions as DynamoDB stream event consumers, so that simulation runs can forecast future order completion times on every state change.&lt;br&gt;
For each run, the complete system state is fetched from the DynamoDB (which might actually need multiple requests, since a single scan might only return a page of up to 1 MB of data).&lt;br&gt;
Based on the registered process timestamps, the currently relevant process step of each order can be identified.&lt;br&gt;
The simulation model is generated from the process diagram shown above using 
&lt;a href=&#34;../casymda/&#34;&gt;Casymda&lt;/a&gt;.
For the sake of simplicity of this proof of concept, processing times are assumed to be deterministic (even though stochastic behavior could be easily modeled, it would require averaging multiple runs).
Model blocks are implemented to account for already elapsed processing time of &lt;em&gt;work-in-process&lt;/em&gt;-entities at the start of the simulation (one of the possibilities to initialize &lt;em&gt;online simulation&lt;/em&gt; models discussed in the often-cited paper of 
&lt;a href=&#34;https://informs-sim.org/wsc05papers/222.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hanisch and Tolujew, 2005&lt;/a&gt;, further explored by 
&lt;a href=&#34;https://d-nb.info/987148664/34&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hotz, 2007&lt;/a&gt;).
During the execution, forecast metrics are collected in form of predicted process step completion times.
Currently, AWS allows Lambda function executions to take up to 15 minutes, so that even complex models can be run this way.
However, frequent and long running calculations might make it more attractive to create a dedicated service.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./img/icons/plotly_dash_icon.png&#34; alt=&#34;dash&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;6--7-forecast-persistence-and-visualization&#34;&gt;6. + 7. Forecast persistence and visualization&lt;/h4&gt;
&lt;p&gt;At the end of each run, the gathered results are persisted in a second DynamoDB table, from where a dashboard application can access and visualize the data.&lt;br&gt;

&lt;a href=&#34;https://github.com/plotly/dash&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Plotly Dash&lt;/a&gt; is a popular framework for analytics web-apps.
It enables the quick creation of dynamic dashboards just by writing Python code.
Under the hood, it uses 
&lt;a href=&#34;https://flask.palletsprojects.com/en/1.1.x/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;flask&lt;/a&gt; to serve 
&lt;a href=&#34;https://dash.plotly.com/react-for-python-developers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;React&lt;/a&gt; websites with 
&lt;a href=&#34;https://github.com/plotly/plotly.js/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;plotly charts&lt;/a&gt; to a browser.
Data queries and analysis are done on the backend using Python.
The implemented dashboard just contains a simple gantt-chart (and serves only as a very basic example, leaving lots of room for extension).
Automatic dashboard refreshes are implemented using an &lt;em&gt;interval&lt;/em&gt;-callback to cyclically poll the database for updates.&lt;br&gt;
A dashboard&amp;rsquo;s Docker container could be run on AWS (e.g. ECS/Fargate, but since the free version of LocalStack does not include this it will just be run locally for demonstration).&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;result&#34;&gt;Result&lt;/h2&gt;
&lt;p&gt;To run the setup locally from within the cloned repository, Docker and Terraform need to be installed.&lt;br&gt;
Even though the performance is not comparable to the actual cloud service, 
&lt;a href=&#34;https://github.com/localstack/localstack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LocalStack&lt;/a&gt; is an awesome option to serve a multitude of AWS services locally, including Kinesis, Lambda, and DynamoDB.
LocalStack can be started in a privileged Docker container, spawning more containers as needed, e.g. for executing Lambdas.
It can be started via:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker-compose up localstack
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Before the Lambda functions can be deployed, the function code and its dependencies need to be packaged:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker-compose up package-ingest-lambda package-simulation-lambda
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.terraform.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Terraform&lt;/a&gt; is a great and widespread tool which can automatically provision infrastructure resources described in configuration files (however, have a look at 
&lt;a href=&#34;https://itnext.io/things-i-wish-i-knew-about-terraform-before-jumping-into-it-43ee92a9dd65&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this article&lt;/a&gt; for a more nuanced analysis).
To create all required resources, two terraform commands are needed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd terraform
terraform init # required once
terraform apply # enter &#39;yes&#39; when prompted to confirm the changes (or use -auto-approve)
cd ../ # return to project root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(To prevent 404 errors when calling &lt;code&gt;apply&lt;/code&gt; after a restart of LocalStack without calling &lt;code&gt;terraform destroy&lt;/code&gt;, first delete the &lt;code&gt;terraform.tfstate&lt;/code&gt; files next to &lt;code&gt;main.tf&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;After the successfull creation, two more containers can be started - one serving the dashboard and one running a simulation model to emulate real event producers:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker-compose up dashboard emulation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Before (re-)starting any test-run, the DynamoDB-tables need to be cleared:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker-compose up truncate-tables
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;http://localhost:8050&#34;&gt;http://localhost:8050&lt;/a&gt; should now show the empty dashboard, while &lt;a href=&#34;http://localhost:5001&#34;&gt;http://localhost:5001&lt;/a&gt; should show the generic Casymda web canvas animation controls.
To enable automatic refreshes use the switch above the chart on the dashboard.&lt;/p&gt;
&lt;p&gt;When starting the emulation, orders will be created at the source and flow through the defined process.&lt;br&gt;
At the same time, the dashboard should update with a minor delay and visualize the completion times of the relevant process steps of all orders which are currently present in the system.
A vertical line in the chart indicates the point in time when the simulation run started and the forecast was created.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;sample-flow&#34;&gt;Sample flow&lt;/h3&gt;
&lt;h4 id=&#34;1-the-first-order-is-created&#34;&gt;1. The first order is created&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;img/sc/e1.png&#34; alt=&#34;e1&#34;&gt;&lt;/p&gt;
&lt;p&gt;The simulation forecasts process step completion times as defined in the model:
&lt;img src=&#34;img/sc/g1.png&#34; alt=&#34;g1&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;2-the-second-order-arrives-and-_order-1_-production-starts&#34;&gt;2. The second order arrives and &lt;em&gt;Order-1&lt;/em&gt; production starts&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;img/sc/e2.png&#34; alt=&#34;e1&#34;&gt;&lt;/p&gt;
&lt;p&gt;The forecast does not show problems:
&lt;img src=&#34;img/sc/g2.png&#34; alt=&#34;g1&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;3-after-some-time-an-eta-update-for-the-_order-2_-material-delivery-is-communicated-and-a-delay-of-13-is-now-expected&#34;&gt;3. After some time, an ETA update for the &lt;em&gt;Order-2&lt;/em&gt; material delivery is communicated, and a delay of 1/3 is now expected&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;img/sc/e3.png&#34; alt=&#34;e1&#34;&gt;&lt;/p&gt;
&lt;p&gt;The forecast shows the announced delay (orange) and the expected shift of the production step of &lt;em&gt;Order-2&lt;/em&gt;:
&lt;img src=&#34;img/sc/g3.png&#34; alt=&#34;g1&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;4-_order-1_-is-finished-and-therefore-excluded-from-the-forecast-but-now-_order-3_-arrives&#34;&gt;4. &lt;em&gt;Order-1&lt;/em&gt; is finished (and therefore excluded from the forecast), but now &lt;em&gt;Order-3&lt;/em&gt; arrives&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;img/sc/e4.png&#34; alt=&#34;e1&#34;&gt;&lt;/p&gt;
&lt;p&gt;The forecast reveals an upcoming problem! Caused by the capacity constraint of the production step (max. one order concurrently), the delay of &lt;em&gt;Order-2&lt;/em&gt; (orange) will also prevent to start the of production of &lt;em&gt;Order-3&lt;/em&gt; on time, even though the material is expected to be ready by then (red):
&lt;img src=&#34;img/sc/g4.png&#34; alt=&#34;g1&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;5-when-_order-2_-is-almost-finished-a-4th-order-comes-in&#34;&gt;5. When &lt;em&gt;Order-2&lt;/em&gt; is almost finished, a 4th order comes in&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;img/sc/e5.png&#34; alt=&#34;e1&#34;&gt;&lt;/p&gt;
&lt;p&gt;As the forecast shows, the delay of &lt;em&gt;Order-2&lt;/em&gt; will cascade and also affect &lt;em&gt;Order-4&lt;/em&gt;:
&lt;img src=&#34;img/sc/g5.png&#34; alt=&#34;g1&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Complete screen-cast:&lt;/p&gt;
&lt;video autoplay controls&gt;
  &lt;source src=&#34;img/sc/peek5.mp4&#34; type=&#34;video/mp4&#34;&gt;
&lt;/video&gt;
&lt;hr&gt;
&lt;p&gt;While this was just a proof of concept and the presented example would have been easy to calculate by hand, there are plenty of improvements and extensions imaginable.&lt;/p&gt;
&lt;p&gt;Looking at the scenario and business use-case, it would be interesting to add more complexity to the process, such as inventory for raw materials, and different replenishment strategies.
Similarly, the impacts of stochastic or planned machine maintenance intervals might be evaluated.
Another extension would be to incorporate targets into the process, such as order-specific due dates or throughput goals.
This might then ask for additional optimization procedures to determine optimal production control policies (similar to the case presented in the thesis mentioned in the beginning of this article).&lt;/p&gt;
&lt;p&gt;Interesting technical extensions include security aspects such as authentication and authorization of different data producing parties, as well as an integration of the IoT-related services of AWS, which might offer dedicated features to gather data with sensors and edge devices for the digital twin.
Concerning the analytics of ingested event data, stream processing solutions such as &lt;em&gt;AWS Kinesis Data Analytics&lt;/em&gt; might be useful to identify relevant patterns and trigger forecast and optimization runs only in case of critical process deviations.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Logistics Process Models for Automated Integration Testing</title>
      <link>/post/csa-vcom/</link>
      <pubDate>Sun, 24 May 2020 00:00:00 +0000</pubDate>
      <guid>/post/csa-vcom/</guid>
      <description>&lt;p&gt;The planning and design of logistics systems - both at supply-chain and intralogistics level - is frequently supported by simulation studies, used for comparing design alternatives, assessing their feasibility, as well as estimating KPIs like lead-time or throughput.&lt;/p&gt;
&lt;p&gt;When it comes to the realization phase of logistics systems, major challenges relate to the development of controls and operational IT systems.
Given the fact that testing, integration, commissioning (and bug-fixing) of these systems tend to consume a significant chunk of the realization phase, it becomes clear that it is beneficial to test a developed system as early as possible - even before physical construction takes place.&lt;br&gt;

&lt;a href=&#34;https://www.sciencedirect.com/science/article/pii/S2212827119305839&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;Virtual Commissioning&lt;/em&gt;&lt;/a&gt; describes the testing of software against the digital counterpart of a real system, making use of &lt;em&gt;simulation&lt;/em&gt; models to &lt;em&gt;emulate&lt;/em&gt; real-world interaction.&lt;/p&gt;
&lt;p&gt;This post will show an example of how the integration of simulation-based testing into today&amp;rsquo;s agile software development processes can look like, investigating a case-study on order management &amp;amp; delivery optimization.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;Get the repo from github: &lt;a href=&#34;https://github.com/fladdimir/csa-vcom&#34;&gt;https://github.com/fladdimir/csa-vcom&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-scenario--scope&#34;&gt;1. Scenario &amp;amp; Scope&lt;/h2&gt;
&lt;p&gt;Remember 
&lt;a href=&#34;https://www.die-patisserie.de/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;La Pâtisserie&lt;/em&gt;&lt;/a&gt;, the small French bakery in Hamburg-Altona, which was experiencing 
&lt;a href=&#34;../csa-streetmap/&#34;&gt;a massive shift of demand towards at-home delivery&lt;/a&gt; of their sweet pastries?&lt;/p&gt;
&lt;p&gt;Having evaluated different options of how to scale their business-model with help of an innovative open-source approach to urban delivery network simulation, the growing network now gets harder and harder to manage, calling for an increased software-based support of the bakery&amp;rsquo;s daily logistics operations&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;2-processes--requirements&#34;&gt;2. Processes &amp;amp; Requirements&lt;/h2&gt;
&lt;p&gt;To be able to focus on their core-competencies (to conjure up delicious treats, instead of fighting intractably inconsistent spread-sheet data), our bakery decides to go for a web-based logistics planning application.&lt;br&gt;
The core processes to be supported are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Registration of customers, and tracking their orders&lt;/li&gt;
&lt;li&gt;Managing locations of the depots to plan the best-possible deliveries&lt;/li&gt;
&lt;li&gt;Keeping track of the trucks, delivering goods according to the planned tours&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following BPMN-diagram shows the the processes and a simple token-flow animation:&lt;/p&gt;
&lt;video autoplay loop controls&gt;
  &lt;source src=&#34;img/bpmn.mp4&#34; type=&#34;video/mp4&#34;&gt;
&lt;/video&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-test-first-simulation-model--build-pipeline&#34;&gt;3. Test First: Simulation Model + Build-Pipeline&lt;/h2&gt;
&lt;p&gt;To make sure that all required processes are adequatly supported by the developed software, our bakery&amp;rsquo;s software development division opts for a test-driven approach, backed by a build-pipeline which automatically checks all code pushed to the repository.&lt;br&gt;
Based on the specified business process a 
&lt;a href=&#34;../casymda&#34;&gt;Casymda&lt;/a&gt; simulation model is generated, ready to emulate the real system, with which the developed software is supposed to work.
As processes and scope of the application change, the simulation model is evolved in an agile way.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://gitea.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gitea&lt;/a&gt; and 
&lt;a href=&#34;https://drone.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Drone&lt;/a&gt; form the basis of the continuous integration infrastructure.
As part of a virtual commissioning step, the pipeline spins up the application in a service-container, against which the simulation model runs the test-scenario, emulating interaction and verifying the expected behavior of the software.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;img/pipeline.png&#34; alt=&#34;pipeline&#34;&gt;&lt;/p&gt;
&lt;p&gt;The pipeline is described by a 
&lt;a href=&#34;https://github.com/fladdimir/csa-vcom/blob/github/.drone.yml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;.drone.yml&lt;/em&gt;&lt;/a&gt; file. Note that the pipeline could be improved in various ways, e.g. by properly waiting for the app (service) to become available for the simulation-step.
A 
&lt;a href=&#34;https://github.com/fladdimir/csa-vcom/blob/github/gitea/docker-compose.yml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;docker-compose.yml&lt;/a&gt; allows to start the gitea+drone setup locally (using a single-instance setup, which is 
&lt;a href=&#34;https://docs.drone.io/server/provider/gitea/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;not ideal&lt;/a&gt;, but sufficient for testing).&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;4-application-design--implementation&#34;&gt;4. Application Design &amp;amp; Implementation&lt;/h2&gt;
&lt;p&gt;Our bakery&amp;rsquo;s app is dealing with management of the data of customers, orders, depots, tours, and trucks.
Additionally, it is required to support planning the delivery process by calculating efficient tours and assigning them to available trucks.&lt;/p&gt;
&lt;p&gt;The app adopts a basic 3-layer structure consisting of a browser-based ui, a backend containing the business logic and optimization algorithms, and a persisting database.
The graphic below summarizes the setup, including the simulation model which acts as a client in the automated build pipeline:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;img/app_layer.png&#34; alt=&#34;app-parts-overview&#34;&gt;&lt;/p&gt;
&lt;p&gt;The backend is implemented using 
&lt;a href=&#34;https://www.djangoproject.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Django&lt;/a&gt;+
&lt;a href=&#34;https://www.django-rest-framework.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Django-Rest-Framework&lt;/a&gt;, and relying on 
&lt;a href=&#34;https://developers.google.com/optimization&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google-OR-Tools&lt;/a&gt; for optimization tasks.
Tour planning is modeled as a capacitated vehicle routing problem with multiple depots.
For an optimal assignment of pending tours to available trucks, OR-Tools offers a minimum-cost-flow solver which is used on a corresponding bi-partite graph.&lt;/p&gt;
&lt;p&gt;To create the required distance matrices, we can utilize the 
&lt;a href=&#34;https://github.com/Project-OSRM/osrm-backend&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Source Routing Machine&lt;/a&gt;, provided as a ready-to-use Docker image (
&lt;a href=&#34;https://hub.docker.com/r/osrm/osrm-backend/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OSRM-in-a-box&lt;/a&gt;).
OSRM offers a convenient API which is synchronously consumed upon creation of a new customer or depot.
Open-street-map data can be downloaded e.g. from &lt;a href=&#34;https://download.geofabrik.de&#34;&gt;https://download.geofabrik.de&lt;/a&gt;.
The map of 
&lt;a href=&#34;https://download.geofabrik.de/europe/germany/hamburg.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hamburg&lt;/a&gt; has a size of ~35 MB and OSRM-preprocessing (car-profile) takes about 30 seconds (i5 dual-core notebook processor).&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.sqlite.org/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SQLite&lt;/a&gt; provides a simple database solution, however, Django makes it easy to switch to a client/server RDBMS like 
&lt;a href=&#34;https://docs.djangoproject.com/en/3.0/ref/databases/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Postgres or MariaDB&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The basic frontend is built with 
&lt;a href=&#34;https://angular.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Angular&lt;/a&gt;, 
&lt;a href=&#34;https://material.angular.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Material&lt;/a&gt;, and 
&lt;a href=&#34;https://leafletjs.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Leaflet.js&lt;/a&gt; (easy to integrate thanks to 
&lt;a href=&#34;https://github.com/Asymmetrik/ngx-leaflet&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ngx-leaflet&lt;/a&gt;).&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;5-result&#34;&gt;5. Result&lt;/h2&gt;
&lt;p&gt;The screencast below shows the workflow from a users perspective. It comprises registering a new customer, issuing an order, planning tours, assignment to a truck, and tracking deliveries as the tour proceeds:&lt;/p&gt;
&lt;video autoplay loop controls&gt;
  &lt;source src=&#34;img/app.mp4&#34; type=&#34;video/mp4&#34;&gt;
&lt;/video&gt;
&lt;p&gt;The shown process matches the one executed by the simulation model in the virtual commissioning pipeline build step, ensuring stable functionality for every version of the software:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;img/drone.png&#34; alt=&#34;drone&#34;&gt;&lt;/p&gt;
&lt;p&gt;Extensive and automated integration testing with simulation models can help to enable and sustain software quality, particularly in the context of process-centric logistics applications.
As we&amp;rsquo;ve seen, today&amp;rsquo;s software development tools and standards allow for an efficient integration of simulation techniques &amp;amp; virtual commissioning approaches into the development process.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Urban Logistics Network Simulation in Python</title>
      <link>/post/csa-streetmap/</link>
      <pubDate>Sat, 04 Apr 2020 00:00:00 +0000</pubDate>
      <guid>/post/csa-streetmap/</guid>
      <description>&lt;p&gt;A really nice and quite unique feature of 
&lt;a href=&#34;https://www.anylogic.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Anylogic&lt;/a&gt; is the possibility to include GIS-maps into simulation models.
It allows to place elements on a map and move them along existing routes, based on real spatial information.
This is cool because it can be used to simulate entire supply chains, including means to provide a great, tangible visualization for complex problems.&lt;/p&gt;
&lt;p&gt;This 
&lt;a href=&#34;../../publication/i3m2017&#34;&gt;previous project&lt;/a&gt; used Anylogic to evaluate different designs and delivery schemes for a more sustainable urban logistics network in the city center of Grenoble in France.
The data-driven simulation model allows to quickly calculate KPIs for various transshipment node locations and different types of transport equipment in a multi-tier supply-chain network.&lt;/p&gt;
&lt;p&gt;Following the success of the feature, Anylogic even built 
&lt;a href=&#34;https://www.anylogistix.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;anyLogistix&lt;/a&gt;, combining pre-built &amp;amp; customizable simulation models with a commercial solver for integrated supply chain planning &amp;amp; optimization.&lt;/p&gt;
&lt;p&gt;Obviously, those commercial features come at a price, so let&amp;rsquo;s see whether this kind of model can also be realized with different means.&lt;/p&gt;
&lt;p&gt;The simulation model of this post will be based on a mini-case-study.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/fladdimir/csa-streetmap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Get the repo from github.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;scenario--scope&#34;&gt;Scenario &amp;amp; Scope&lt;/h2&gt;
&lt;p&gt;Facing the fact that humanity gets more and more used to home-delivery of even everyday necessities, the small French bakery 
&lt;a href=&#34;http://www.die-patisserie.de/de_DE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Die Patisserie&lt;/a&gt; in Hamburg-Altona wants to deliver sweet pastries to nearby customers.&lt;/p&gt;
&lt;p&gt;3 major purchasers were identified: the lost-and-found office 
&lt;a href=&#34;https://www.hamburg.de/altona/fundbuero/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Zentrales Fundbüro&lt;/a&gt;, 
&lt;a href=&#34;https://www.monkeys-hamburg.de/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Monkeys Music Club&lt;/a&gt;, and the publishing house 
&lt;a href=&#34;https://www.carlsen.de/node/18749&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Carlsen Verlag&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Coordinates of the different locations:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Node&lt;/th&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Lat&lt;/th&gt;
&lt;th&gt;Lon&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;PAT&lt;/td&gt;
&lt;td&gt;Die Patisserie&lt;/td&gt;
&lt;td&gt;53.55668&lt;/td&gt;
&lt;td&gt;9.92815&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;ZFB&lt;/td&gt;
&lt;td&gt;Zentrales Fundbüro (lost-and-found office)&lt;/td&gt;
&lt;td&gt;53.55817&lt;/td&gt;
&lt;td&gt;9.92829&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;MMC&lt;/td&gt;
&lt;td&gt;Monkeys Music Club&lt;/td&gt;
&lt;td&gt;53.55706&lt;/td&gt;
&lt;td&gt;9.93161&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;CAV&lt;/td&gt;
&lt;td&gt;Carlsen Verlag (publishing house)&lt;/td&gt;
&lt;td&gt;53.55703&lt;/td&gt;
&lt;td&gt;9.92684&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;For the sake of simplicity, the order in which nodes are visited is assumed to be fixed. The tour starts &amp;amp; ends at the patisserie:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;img/stations.jpg&#34; alt=&#34;tour-stops&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;simulation-model&#34;&gt;Simulation Model&lt;/h2&gt;
&lt;p&gt;The simulation model for the simplistic scenario is created with:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OSMnx/networkx for retrieving geo-information and calculating shortest-paths&lt;/li&gt;
&lt;li&gt;SimPy/Casymda for simulating the tour&lt;/li&gt;
&lt;li&gt;Leaflet.js for browser-based animation&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-osmnx&#34;&gt;1. OSMnx&lt;/h3&gt;
&lt;p&gt;The awesome 
&lt;a href=&#34;https://github.com/gboeing/osmnx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OSMnx&lt;/a&gt; package provides the possibility to obtain a networkx-graph representation of a street-network from OpenStreetMap with a single line of code.
A relevant section for our scenario can be obtained by specifying center and distance for osm-nodes to be included:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;CENTER = (53.55668, 9.92815)  
DISTANCE = 300
G = ox.graph_from_point(CENTER, distance=DISTANCE, network_type=&#39;drive&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OSMnx lets us pick the nearest osm-node for each of the 4 locations of the tour, and also offers convenient means to plot the network.
Blue dots represent osm-nodes, connected by edges.
The 4 relevant locations are shown in red:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;img/osmnx_plot.jpg&#34; alt=&#34;OSMnx-graph-plot&#34;&gt;&lt;/p&gt;
&lt;p&gt;To prepare all information needed by the simulation model, now all shortest paths between the 4 relevant nodes in the network are computed with networkx, and detailed information on all piece-wise linear segments for each route is included.
The results are pickled and saved to disk to avoid fetching and recalculation for each run of the model (of course its kind to keep the load for the OSM-server as low as possible).&lt;/p&gt;
&lt;p&gt;The above described approach could be improved, e.g. by automatically determining the area to be loaded from the given relevant locations.
Instead of just picking the closest osm-node for each relevant location, it would also be more precise to first go for the closest edge in the network.
And as the network size grows, it might be a better idea to directly query the shortest path between relevant nodes from the OSM-server, instead of fetching the network as a whole (the way Anylogic seems to do it).&lt;/p&gt;
&lt;h3 id=&#34;2-casymdasimpy&#34;&gt;2. Casymda/SimPy&lt;/h3&gt;
&lt;p&gt;
&lt;a href=&#34;../casymda&#34;&gt;Casymda&lt;/a&gt; provides block-based modeling of discrete-event-simulation models on top of 
&lt;a href=&#34;https://pypi.org/project/simpy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SimPy&lt;/a&gt;.&lt;br&gt;
Our model can be characterized by a simple process:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;img/diagram.svg&#34; alt=&#34;bpmn-process&#34;&gt;&lt;/p&gt;
&lt;p&gt;A truck is created at a parameterized &lt;code&gt;Source&lt;/code&gt; and then processed at a custom &lt;code&gt;DriveTour&lt;/code&gt;-block, which contains the logic for elapsing time according to the length of a route and the movement speed of the truck. It also contains the option to calculate intermediate locations for animation. The nodes to be visited are specified via the text-annotation &lt;code&gt;stops=[&amp;quot;ZFB&amp;quot;, &amp;quot;MMC&amp;quot;, &amp;quot;CAV&amp;quot;]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The animation is implemented by exposing information and resources via flask (similar to the &lt;em&gt;tilemap-animation&lt;/em&gt; described in the previous post).&lt;/p&gt;
&lt;h3 id=&#34;3-leafletjs&#34;&gt;3. Leaflet.js&lt;/h3&gt;
&lt;p&gt;To visualize the location of nodes and entities on a map, 
&lt;a href=&#34;https://leafletjs.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Leaflet&lt;/a&gt; only requires a few lines. For setting the rotation angle, there is the 
&lt;a href=&#34;https://github.com/bbecquet/Leaflet.RotatedMarker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rotated.Marker-plugin&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;marker = L.marker(element.coords, { icon: new L.Icon({iconUrl: element.icon_path}) }).addTo(map);
marker.bindPopup(element.text);
marker.setRotationAngle(element.direction);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;result&#34;&gt;Result&lt;/h2&gt;
&lt;p&gt;To run the simulation via &lt;a href=&#34;http://localhost:5000&#34;&gt;http://localhost:5000&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker-compose up geo-web-animation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The 
&lt;a href=&#34;img/tour.mp4&#34;&gt;screencast below&lt;/a&gt; shows a complete tour of a truck visiting all nodes in the defined order (Patisserie - Lost-and-found - Monkey&amp;rsquo;s - Carlsen Publishing - Patisserie).&lt;/p&gt;
&lt;video autoplay loop controls&gt;
  &lt;source src=&#34;img/tour.mp4&#34; type=&#34;video/mp4&#34;&gt;
&lt;/video&gt;
&lt;blockquote&gt;
&lt;p&gt;The one-way street &lt;em&gt;Völckersstraße&lt;/em&gt; is correctly taken into account when moving from &lt;em&gt;Monkeys Music Club&lt;/em&gt; (3., right-most node) to &lt;em&gt;Carlsen Verlag&lt;/em&gt; (4., left-most node).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Of course there are numerous improvements and extensions imaginable, including e.g. the calculation of more realistic driving times based on actual speed limits which are already part of the available OSM-data.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Digital Twin for Assembly Line Supply Strategy Planning</title>
      <link>/post/tugger-routing/</link>
      <pubDate>Sat, 21 Mar 2020 00:00:00 +0000</pubDate>
      <guid>/post/tugger-routing/</guid>
      <description>&lt;p&gt;&lt;em&gt;Artificial Intelligence&lt;/em&gt;, &lt;em&gt;Digital Twins&lt;/em&gt;, &lt;em&gt;Industry 4.0&lt;/em&gt;&amp;hellip; you might have &lt;em&gt;heard&lt;/em&gt; these buzzwords before.&lt;br&gt;
But wouldn&amp;rsquo;t it be cool to &lt;em&gt;apply&lt;/em&gt; them, solving an actual problem?&lt;br&gt;
To learn about practical application rather than abstract concepts?&lt;br&gt;
To know which challenges to master, and which pitfalls to avoid?&lt;/p&gt;
&lt;p&gt;Great, so this article is for &lt;em&gt;you&lt;/em&gt;!&lt;br&gt;
It will..&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;describe how to use reinforcement learning to solve a production-logistics problem&lt;/li&gt;
&lt;li&gt;explain basic concepts of reinforcement learning and industrial digital twins&lt;/li&gt;
&lt;li&gt;present an in-depth case-study on assembly line supply strategy planning&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And it will include code, ready for execution on &lt;em&gt;your&lt;/em&gt; machine. Docker-based, no further installation needed.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Get the repo:
&lt;a href=&#34;https://github.com/fladdimir/tugger-routing&#34;&gt;https://github.com/fladdimir/tugger-routing&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Disclaimer:&lt;/em&gt;
This article is the result of leisure-time work. It represents our individual perspectives on the discussed topics. It&amp;rsquo;s a report capturing our personal experiences, rather than a purely scientific study. The content, concepts, and their implementation can probably be improved in virtually any imaginable way.&lt;br&gt;
We still hope that you enjoy reading.&lt;/p&gt;
&lt;!-- omit in toc --&gt;
&lt;h2 id=&#34;outline&#34;&gt;Outline&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#introduction--basics&#34;&gt;Introduction &amp;amp; Basics&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#reinforcement-learning&#34;&gt;Reinforcement Learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#digital-twins-and-discrete-event-simulation&#34;&gt;Digital Twins and Discrete Event Simulation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#wrapping-a-des-model-in-a-gym-environment&#34;&gt;Wrapping a DES-Model in a Gym-Environment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#case-study&#34;&gt;Case-Study&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#scenario&#34;&gt;Scenario&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#simulation-model&#34;&gt;Simulation Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#preparing-the-gym-environment&#34;&gt;Preparing the Gym-Environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#rl-agent-training--evaluation&#34;&gt;RL-Agent Training &amp;amp; Evaluation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#performance-comparison&#34;&gt;Performance Comparison&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#summing-up&#34;&gt;Summing Up&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;introduction--basics&#34;&gt;Introduction &amp;amp; Basics&lt;/h2&gt;
&lt;p&gt;Reinforcement learning represents an emerging technique from machine learning.
It can autonomously derive complex action sequences in dynamic environments and is successfully applied in various fields, e.g. from 
&lt;a href=&#34;https://openai.com/blog/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;robotics and gaming&lt;/a&gt;.
Instead of explicitly defining a specific solution strategy for a problem, we can just provide an &lt;em&gt;environment&lt;/em&gt;. A self-learning &lt;em&gt;agent&lt;/em&gt; will then autonomously discover successful strategies just by interaction.&lt;/p&gt;
&lt;p&gt;Needless to say, there is nothing new under the moon and 
&lt;a href=&#34;https://www.researchgate.net/publication/326039529_Optimization_of_global_production_scheduling_with_deep_reinforcement_learning&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;previous studies&lt;/a&gt; show the general feasibility of using RL for solving production-logistics problems.&lt;/p&gt;
&lt;p&gt;So why do we think that there is the need for yet another article about this very topic?&lt;/p&gt;
&lt;p&gt;First, there is a lot of active development in &lt;em&gt;RL&lt;/em&gt;, as well as in the application of &lt;em&gt;Digital Twins&lt;/em&gt; in production/logistics.
We believe that there lies even more potential in integrating these concepts.
Furthermore, we found the often derogatory-treated &lt;em&gt;&amp;ldquo;low-level implementation work&amp;rdquo;&lt;/em&gt; to be an actual obstacle for making progress in this challenging and highly inter-disciplinary area of applied research.
This contribution strives to show a working example based on a tool-stack which seamlessly integrates two of the most popular open-source software packages from their respective areas:

&lt;a href=&#34;https://stable-baselines.readthedocs.io/en/master/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;stable-baselines&lt;/a&gt; for &lt;em&gt;RL&lt;/em&gt; and 
&lt;a href=&#34;https://simpy.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SimPy&lt;/a&gt; for implementing &lt;em&gt;Digital Twins&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&#34;reinforcement-learning&#34;&gt;Reinforcement Learning&lt;/h3&gt;
&lt;p&gt;If you still ask yourself what RL is capable of, we definitely recommend to have a look at 
&lt;a href=&#34;https://openai.com/blog/emergent-tool-use/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;what the guys from openai are doing&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Admittedly, thats probably a quite sophisticated and highly engineered example, but it breaks down to a simple interaction between an &lt;em&gt;agent&lt;/em&gt; and an &lt;em&gt;environment&lt;/em&gt;.
Technically, this interaction is defined by an interface (or abstract base-class as Python likes to put it), which is part of the 
&lt;a href=&#34;https://gym.openai.com/docs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gym-package&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The graphic below illustrates the exchange of information between agent and environment.
First, the agent calls the environment&amp;rsquo;s &lt;em&gt;step&lt;/em&gt; method, providing the action to be executed.
The environment then processes the action and returns:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the new state of the system (&lt;em&gt;observation&lt;/em&gt;),&lt;/li&gt;
&lt;li&gt;the &lt;em&gt;reward&lt;/em&gt; which occured during the step (might be zero),&lt;/li&gt;
&lt;li&gt;a &lt;em&gt;done&lt;/em&gt; value potentially indicating the end of an episode (and the need for a subsequent &lt;em&gt;reset&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;and an &lt;em&gt;info&lt;/em&gt;-object (might contain additional information e.g. for logging purposes).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;diagrams/gym_rl_environment_interface.jpg&#34; alt=&#34;Gym-RL-Environment-Interface&#34;&gt;&lt;/p&gt;
&lt;p&gt;The interface also prescribes more, such as the formats of &lt;em&gt;action-space&lt;/em&gt; and &lt;em&gt;observation_space&lt;/em&gt;, as well as &lt;em&gt;render&lt;/em&gt; and &lt;em&gt;reset&lt;/em&gt; behavior.&lt;br&gt;
The various RL algorithms provided by the 
&lt;a href=&#34;https://pypi.org/project/stable-baselines/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;stable-baselines&lt;/a&gt;-package are ready to work with environments implementing this gym-interface.
All that is left to do is creating a compliant environment - and in the next section we will show how this can be achieved in the domain of logistics.&lt;/p&gt;
&lt;h3 id=&#34;digital-twins-and-discrete-event-simulation&#34;&gt;Digital Twins and Discrete Event Simulation&lt;/h3&gt;
&lt;p&gt;Frankly, &lt;em&gt;Digital Twin&lt;/em&gt; is probably the most overused buzzword of all the &amp;ldquo;Lostistics 4.0 / Industry 4.0&amp;rdquo; stuff that is out there.
Even though we could not resist to put it into the title, from now on we&amp;rsquo;ll prove that we can do better and use the more specific term &amp;ldquo;Discrete Event Simulation&amp;rdquo; (DES).&lt;/p&gt;
&lt;p&gt;Why DES? Discrete Event Simulation is one of the widespread tools for analysis and design of logistics systems.
Today&amp;rsquo;s applications go beyond the traditional usage for systems planning.
They include more operational use-cases such as virtual commissioning or short-term forecasts.
Simulation models are getting integrated tightly into other IT-systems.
This allows to increase process transparency and to improve our means to analyze, control, and optimize system performance in real-time.
Doesn&amp;rsquo;t this sound pretty close to what &lt;em&gt;Digital Twins&lt;/em&gt; always promise?&lt;/p&gt;
&lt;p&gt;Most industrial simulation uses are still based on commercial packages.&lt;br&gt;
However, there are a couple of open-source alternatives, which are typically closer to general-purpose language programming. Even though they tend to lack some convenient commercial features, there are upsides such as better scalability and simplified interfacing.&lt;/p&gt;
&lt;p&gt;Related to Python we became aware of two popular DES packages: 
&lt;a href=&#34;https://www.salabim.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Salabim&lt;/a&gt; and 
&lt;a href=&#34;https://simpy.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SimPy&lt;/a&gt;.
Both are not only free and open-source, but even built on top of the standard library of one of the world&amp;rsquo;s most popular programming languages - let&amp;rsquo;s see what we can get out of that!&lt;/p&gt;
&lt;!-- omit in toc --&gt;
&lt;h4 id=&#34;casymda-package&#34;&gt;Casymda-Package&lt;/h4&gt;
&lt;p&gt;Based on &lt;em&gt;SimPy&lt;/em&gt;, we added bits of complementing functionality to gain some of the modeling convenience of commercial &amp;ldquo;block-based&amp;rdquo; DES-packages.&lt;br&gt;

&lt;a href=&#34;https://pypi.org/project/casymda/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;Casymda&lt;/em&gt;&lt;/a&gt; facilitates the usage of bpmn-process-descriptions to generate corresponding simulation-model python-code.
.bpmn-files (basically xml) can easily be created with the 
&lt;a href=&#34;http://www.bpmn.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Camunda-Modeler&lt;/a&gt;.&lt;br&gt;
This graphical modeling helps to maintain an overview of the high-level model-structure.
Generated Casymda-models also include a generic, token-like animation of simulated processes out-of-the-box, ready to be run in a web-browser.
For presentation and debugging, animations can be paused and their speed can be changed dynamically.
Solely animation-related events are not scheduled if the simulation is run without visualization.
This maximizes the execution speed - which becomes especially important related to RL, when a high number of runs is necessary.&lt;br&gt;
Further features of Casymda include simulated movements along shortest paths in a 2D-tilemap-space, and gradual typing for development convenience (checkout 
&lt;a href=&#34;https://github.com/microsoft/pyright&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pyright&lt;/a&gt; if you are using 
&lt;a href=&#34;https://code.visualstudio.com/docs/python/editing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;vscode&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;For more info on &lt;em&gt;Casymda&lt;/em&gt; have a look at 
&lt;a href=&#34;https://github.com/fladdimir/casymda&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;the repo&lt;/a&gt; or 
&lt;a href=&#34;https://casymda.github.io/page/Webpage/Startpage.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;the (German) website&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;wrapping-a-des-model-in-a-gym-environment&#34;&gt;Wrapping a DES-Model in a Gym-Environment&lt;/h3&gt;
&lt;p&gt;To be able to train an RL-agent inside a simulation model, we need to make the model implementing the Gym-interface described above.&lt;/p&gt;
&lt;p&gt;The following diagram illustrates the coupling concept:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrams/sim_env_wrapper.jpg&#34; alt=&#34;Gym-environment wrapper for a simulation model&#34;&gt;&lt;/p&gt;
&lt;p&gt;When the &lt;code&gt;step&lt;/code&gt; function of the Gym-Environment is called (&lt;code&gt;1&lt;/code&gt;), the provided action is propagated to the relevant block of the simulation model (&lt;code&gt;1.1&lt;/code&gt;).
This is realized with help of an &lt;code&gt;ActionHolder&lt;/code&gt;, so that a consuming piece of decision logic can dispatch according to the received information.&lt;/p&gt;
&lt;p&gt;Subsequently, the simulation is executed until a &lt;code&gt;next_action_needed&lt;/code&gt;-Event is triggered by the simulation model (&lt;code&gt;1.2&lt;/code&gt;).
This is indicating the end of the current step and the need for another action of the agent.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One &lt;em&gt;Gym-step&lt;/em&gt; can thus comprise an arbitrary number of discrete &lt;em&gt;SimPy-steps&lt;/em&gt;, each of which can in turn take an arbitrary amount of simulated time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Rewards are managed with help of a &lt;code&gt;RewardHolder&lt;/code&gt; object, which is wired into the relevant blocks of the simulation model during environment initialization.
At the end of each step, occured rewards are collected (&lt;code&gt;1.3&lt;/code&gt;). Depending on the type of the optimization problem to solve, a post-processing of collected rewards can be applied (e.g. taking into account the amount elapsed time, so that an agent can learn time-efficient behavior).&lt;/p&gt;
&lt;p&gt;To check whether an episode ended (the &lt;em&gt;done&lt;/em&gt; part of the returned information), the current state of the model is checked against configured &lt;code&gt;done_criteria&lt;/code&gt; (&lt;code&gt;1.4&lt;/code&gt;).
These can contain e.g. some goals to be reached or a certain amount of time to be simulated.&lt;/p&gt;
&lt;p&gt;To provide the agent with an observation, a model-specific &lt;code&gt;ModelStateToObservationConverter&lt;/code&gt; is used to collect relevant information from the model.
The created observation conforms to the defined &lt;code&gt;observation_space&lt;/code&gt; (&lt;code&gt;1.5&lt;/code&gt;).
This step could include e.g. counting the number of entities in different queues or checking inventory levels and creating a NumPy-array out of this information.&lt;/p&gt;
&lt;p&gt;Finally, collected information is returned to the agent (&lt;code&gt;2&lt;/code&gt;), which can learn based on the reward and decide for the next action.&lt;/p&gt;
&lt;p&gt;Having the basics covered, let&amp;rsquo;s see how we get this to work.&lt;/p&gt;
&lt;h2 id=&#34;case-study&#34;&gt;Case-Study&lt;/h2&gt;
&lt;p&gt;Back in August of last year at the MIM2019 in Berlin, we had the chance to attend an interesting talk of two Bavarian guys presenting their research on 
&lt;a href=&#34;https://www.sciencedirect.com/science/article/pii/S2405896319315010&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;improving the tour-building for in-plant milk-run systems&lt;/a&gt;.
These internal deliveries are commonly used for assembly line supply, and the tours are typically following a very rigid plan.
Given the fact that the actual demand at the line tends to vary, their research revealed quite a lot of potential to decrease delivery lead times and to increase systems&amp;rsquo; utilization - just by making the tour-planning more dynamic.&lt;/p&gt;
&lt;p&gt;Based on this setting we constructed an abstracted and simplified version of an assembly line with a corresponding material supply system to provide a playground for reinforcement learning algorithms.&lt;/p&gt;
&lt;h3 id=&#34;scenario&#34;&gt;Scenario&lt;/h3&gt;
&lt;p&gt;The image below shows a schematic layout plan of the system:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/layout_50perc.png&#34; alt=&#34;case-study-layout&#34;&gt;&lt;/p&gt;
&lt;p&gt;Unfinished products enter the system on the upper right (&lt;code&gt;I&lt;/code&gt;) and are assembled sequentially at 9 different stations, arranged in U-shape (&lt;code&gt;I-IX&lt;/code&gt;).
Finished products leave the system after the last assembly step (&lt;code&gt;IX&lt;/code&gt;).&lt;br&gt;
Stations require a certain amount of resource of either type &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; to be present in the station&amp;rsquo;s inventory before an assembly step can start.&lt;br&gt;
Each station can only hold one product at a time, and finished products can only be forwarded once the following station is empty (thus multiple upstream stations holding already finished products may be blocked by downstream stations which are still processing a product or waiting for material before being able to start processing).&lt;br&gt;
Material is supplied by a tugger, able to carry a limited discrete amount (&amp;ldquo;boxes&amp;rdquo;). The tugger can load material at a stock (&lt;code&gt;A&lt;/code&gt; and/or &lt;code&gt;B&lt;/code&gt;, located at the bottom).
1 discrete unit of material (&amp;ldquo;box&amp;rdquo;) can be loaded/unloaded at a time.
The goal of the assembly line is achieving the maximal throughput, which also correlates with small lead-times of products.&lt;/p&gt;
&lt;p&gt;Assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;material can only be loaded at the stocks (&lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;), each of which holds an infinite amount of material, so that the tugger never waits for material at a loading site&lt;/li&gt;
&lt;li&gt;material can only be unloaded at a station actually requiring this type of material (hence a tugger cannot unload a box of &lt;code&gt;A&lt;/code&gt; at a station which needs &lt;code&gt;B&lt;/code&gt; for assembly)&lt;/li&gt;
&lt;li&gt;the inventory capacity at the stations (&lt;code&gt;I-IX&lt;/code&gt;) is infinite, so that the tugger never waits at an unloading site (otherwise livelocks could occur where a tugger cannot unload material wherever it moves)&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;System parameters&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Takt-time: processing time per station per product&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;60s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Demand per product of stations type &lt;code&gt;A&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.5 units&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Demand per product of stations type &lt;code&gt;B&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.5 units&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Tugger movement speed&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10 m/s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Tugger capacity&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;25 units&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Amount of material (un-)loaded per step&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;5 units&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Time needed per (un-)loading step&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;5s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Distances between stocks and stations (higher demands cause more frequent tours):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Relation&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Simple&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Demand-weighted&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;A -&amp;gt; T1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1096.40m&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1644.60m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;B -&amp;gt; T2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;926.40m&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;463.20m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;A -&amp;gt; T3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;736.40m&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1104.60m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;B -&amp;gt; T4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;566.40m&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;283.20m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;A -&amp;gt; T5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;234.10m&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;351.15m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;B -&amp;gt; T6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;556.40m&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;278.20m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;A -&amp;gt; T7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;726.40m&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1089.60m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;B -&amp;gt; T8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;916.40m&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;458.20m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;A -&amp;gt; T9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1086.40m&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1629.60m&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The table below shows a simple throughput estimation by calculating the average cycle time of the tugger and the expected station utilization.
The estimation assumes &amp;ldquo;full truck loads&amp;rdquo;, always completely loading at one stock (either &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;), and fully unloading at a station (&lt;code&gt;T1&lt;/code&gt; - &lt;code&gt;T9&lt;/code&gt;).&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Throughput estimation&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Max throughput 24h&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;60/h x 24h = 1440&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Demand / product&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9.5 units&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Demand / time&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9.5 / 60s = 0.16/s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Average weighted distance&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;811.37m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Average driving time&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;81.137s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;(Un-)loading time 25 units&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;25s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Average cycle time&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(81.137s + 25s) x 2 = 212.274s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Delivered units / cycle&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;25&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Delivered units / time&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.12/s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Average utilization&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.12/s / 0.16/s = 75%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Expected throughput per min&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;75% x 60/min = 45/min&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Expected throughput per 24h&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;~1080/24h&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As we can see, the delivery performance of the tugger represents the limiting factor (bottleneck) of the system, which means that each improvement made here will be directly reflected by a corresponding increase in the overall throughput.&lt;br&gt;
For the sake of simplicity, no stochastic model behaviour (such as e.g. randomly distributed loading or movement times) is assumed, hence the simulation model will be deterministic.&lt;br&gt;
As stated: the system as a whole is quite abstracted and simplified - but still capturing at least some of the basic complexity inherent to real-world problems.
Will our RL-agent be able to&amp;hellip;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;grasp the underlying mechanics?&lt;/li&gt;
&lt;li&gt;distinguish different product types?&lt;/li&gt;
&lt;li&gt;discover the spots of demand and supply?&lt;/li&gt;
&lt;li&gt;deal with the limits of the tugger&amp;rsquo;s capacity?&lt;/li&gt;
&lt;li&gt;reach the maximal possible throughput?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We&amp;rsquo;ll find out, but let&amp;rsquo;s first have a look at what the learning environment will look like.&lt;/p&gt;
&lt;h3 id=&#34;simulation-model&#34;&gt;Simulation Model&lt;/h3&gt;
&lt;p&gt;The 
&lt;a href=&#34;https://github.com/fladdimir/tugger-routing/tree/github/tugger_src/gym_env/des_model&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;simulation model&lt;/a&gt; of the system basically consists of 2 processes, both depicted in the graphic below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/model.jpeg&#34; alt=&#34;case-study-processes&#34;&gt;&lt;/p&gt;
&lt;p&gt;On the left side, products pass through the 9 assembly steps (&lt;code&gt;ProductStation&lt;/code&gt;, rotated U-shape) before leaving the system, occasionally being blocked by downstream stations or waiting for material at a station.&lt;/p&gt;
&lt;p&gt;On the right side the tugger passes through an infinite cycle of movement and loading/unloading process steps (after initial creation at location &lt;code&gt;A&lt;/code&gt; by a &lt;code&gt;TuggerSource&lt;/code&gt;):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the next movement target is chosen and the movement is completed (no actual movement if the next target equals the current location) (&lt;code&gt;TuggerMovement&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Depending on the current location (being either a stock &lt;code&gt;A&lt;/code&gt;/&lt;code&gt;B&lt;/code&gt;) or a &lt;code&gt;ProductStation&lt;/code&gt;, the next tugger process step is chosen:
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;TuggerStock A&lt;/code&gt; loading of one unit of &lt;code&gt;A&lt;/code&gt; (if tugger-capacity not reached)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TuggerStock B&lt;/code&gt; loading of one unit of &lt;code&gt;B&lt;/code&gt; (if tugger-capacity not reached)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TuggerStation&lt;/code&gt; unloading of one unit of &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; if possible (material required by station is loaded)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note that even unsuccessful loading or unloading attempts are implemented to take a small, fixed amount of time, so that every possible Gym-step is guaranteed to take at least some simulated time (and a time-constrained episode is guaranteed to reach its end eventually).&lt;/p&gt;
&lt;p&gt;Below you can see a process animation, as well as an animation of a tilemap.
The agent here follows an explicitly defined simple rule of always delivering a complete load of 25 units to the station with the lowest inventory level.
To run the animation just clone the 
&lt;a href=&#34;https://github.com/fladdimir/tugger-routing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;repo&lt;/a&gt;, run the command, and visit &lt;a href=&#34;http://localhost:5000&#34;&gt;http://localhost:5000&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Process animation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker-compose up web-animation-lia-process
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;gifs/lia_process.gif&#34; alt=&#34;lia-process&#34;&gt;&lt;/p&gt;
&lt;p&gt;Tilemap animation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker-compose up web-animation-lia
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;gifs/lia_tilemap.gif&#34; alt=&#34;lia-tilemap&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;preparing-the-gym-environment&#34;&gt;Preparing the Gym-Environment&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;TuggerEnv&lt;/code&gt; implements the Gym-Env interface and wraps the simulation model to be used for RL-agent training.&lt;/p&gt;
&lt;p&gt;Generic functionalities like the mandatory &lt;code&gt;step&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt; functions and related helper methods are inherited and abstract/default parent-methods are overridden in a model-specific way as required (&lt;em&gt;Template-Method Pattern&lt;/em&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;initialize_action_and_reward_holder&lt;/code&gt; specifies which model blocks&amp;hellip;
&lt;ul&gt;
&lt;li&gt;need access to gym-actions: &lt;code&gt;TilemapMovement&lt;/code&gt;, choosing the next movement target based on the supplied target index number&lt;/li&gt;
&lt;li&gt;log achieved rewards: &lt;code&gt;ProductSink&lt;/code&gt;, simply counting a reward of 1 for each finished product&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get_reward&lt;/code&gt; specifies how the elapsed time is taken into account for reward calculation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;check_if_model_is_done&lt;/code&gt; implements a model-specific check whether a certain amount of time has been simulated. One episode is scheduled to take 24h (86400s).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;code&gt;render&lt;/code&gt; method of the Gym-Env is not implemented, since animations at arbitrary moments in time - whenever a Gym-step is finished - do not make much sense for discrete event simulation environments. The animation is controlled separately.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;info&lt;/code&gt; return value of &lt;code&gt;step&lt;/code&gt; is configured to return the number of &lt;code&gt;finished_products&lt;/code&gt; which can then be logged.&lt;/p&gt;
&lt;!-- omit in toc --&gt;
&lt;h4 id=&#34;observation---action-space&#34;&gt;Observation- &amp;amp; Action-Space&lt;/h4&gt;
&lt;p&gt;The model-specific extraction of the observation from the current model state is done by an instance of a &lt;code&gt;TuggerEnvModelStateConverter&lt;/code&gt; which implements the &lt;code&gt;ModelStateConverter&lt;/code&gt; &amp;ldquo;interface&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Specifically, the observation consists of the following information which describes the current state of the system (overall 48 values):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ProductStation&lt;/code&gt; observations (5 values x 9 stations = 45 values):
&lt;ul&gt;
&lt;li&gt;current inventory-level (normalized 0-1, counted up to a limit of 10 units)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;busy&lt;/em&gt;-state (binary)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;waiting_for_material&lt;/em&gt;-state (binary)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;empty&lt;/em&gt;-state (binary, whether a product is present or not)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;blocked-by-successor&lt;/em&gt;-state (binary)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TuggerEntity&lt;/code&gt; observations (3 values x 1 tugger = 3 values):
&lt;ul&gt;
&lt;li&gt;loaded amount of &lt;code&gt;A&lt;/code&gt; (relative to capacity)&lt;/li&gt;
&lt;li&gt;loaded amount of &lt;code&gt;B&lt;/code&gt; (relative to capacity)&lt;/li&gt;
&lt;li&gt;current location (index)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that parts of a station observation can be seen to be redundant (e.g. a station which is neither &lt;em&gt;busy&lt;/em&gt; nor &lt;em&gt;waiting&lt;/em&gt; nor &lt;em&gt;empty&lt;/em&gt; can only be &lt;em&gt;blocked&lt;/em&gt;) - behind lies the rationale that an intelligent algorithm will (hopefully) learn an importance of different components of an observation, so that we do not have to worry about more than providing all potentially useful information.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;action_space&lt;/code&gt; (of type &lt;code&gt;gym.spaces.Discrete&lt;/code&gt;) consists of the 11 possible movement targets (9 stations + 2 stocks, encoded by index).&lt;/p&gt;
&lt;!-- omit in toc --&gt;
&lt;h4 id=&#34;rewards&#34;&gt;Rewards&lt;/h4&gt;
&lt;p&gt;As stated above, the defined goal of the assembly line is to achieve the best possible throughput of products, which corresponds to producing as many products as possible e.g. during one episode (24h).&lt;/p&gt;
&lt;p&gt;How do we achieve that? Which kind of incentive is suitable to stimulate such a behavior?
The design of appropriate reward functions is known to be a non-trivial matter.
In fact, the design of rewards and incentives even for (arguably more intelligent) humans is a major problem in management and education (remember the last time you studied for passing an exam instead of actually learning useful contents).&lt;/p&gt;
&lt;p&gt;For the environment at hand, we could just think about giving a single reward at the end of each episode, proportionally to the number of achieved products in that fixed amount of time (24h), which would probably properly reflect our aim of maximizing the throughput.
However, the resulting reward would be quite &lt;em&gt;sparse&lt;/em&gt; and therefore greatly decelerate learning speed (taking the average duration of a random action, each episode would take more than 1000 actions to complete before an agent sees any reward).&lt;/p&gt;
&lt;p&gt;Another idea would be to reward every successful delivery of material to any station, which would be possible to be completed within 2 steps (movement to the stock &amp;amp; movement to a suitable station consuming the loaded material).
This way we would get less sparse rewards, but also an obvious problem of exploitability, caused by the fact that the delivery of material to one station alone would actually never lead to the completion of any product at all.&lt;/p&gt;
&lt;p&gt;As a compromise, we simply decided to go for a reward of 1 everytime a product completes its final assembly step, which is possible be completed within 12 steps (minimum, not necessarily an optimal strategy).
Even exhibiting a random behavior, this would allow an agent to generate a reward of around 50 during one episode, so that there are sufficient &amp;ldquo;randomly succesful&amp;rdquo; samples to learn from.&lt;/p&gt;
&lt;p&gt;One problem with this reward comes from the fact that the simulated time needed to obtain a reward is not reflected by the reward itself.
Since every gym-step can actually eat up a greatly varying amount of simulation time (from 5 seconds to &amp;gt;100), there is a huge implicit impact on the throughput, which the agent is unaware of.
To solve this problem we introduced &amp;ldquo;costs of time&amp;rdquo;, which means we simply give a small negative reward every step, proportional to the amount of simulated time that passed.
This finally leaves us with the subsequent question of how big these &amp;ldquo;costs&amp;rdquo; should be.
If set too high, they would just overrule any of the few actual rewards at the beginning of the training.
If put too low, there would not be sufficient stimulus to exhibit time-efficient behavior at all.
Again, as a simple compromise, we implemented the costs to grow proportionally with the highest reward seen so far at the end of an episode, which guarantees a certain balance, and rewards increasing time-efficiency.&lt;/p&gt;
&lt;p&gt;The above described reward that we designed is definitely not &amp;ldquo;perfect&amp;rdquo; and also feels a bit like putting too much effort into &amp;ldquo;reward engineering&amp;rdquo; - nevertheless its a first solution our agents can hopefully work with&amp;hellip;&lt;/p&gt;
&lt;h3 id=&#34;rl-agent-training--evaluation&#34;&gt;RL-Agent Training &amp;amp; Evaluation&lt;/h3&gt;
&lt;p&gt;The environment presented above is characterized by a &lt;em&gt;Discrete&lt;/em&gt; action space and a continuous (&lt;em&gt;Box&lt;/em&gt;) observations space.

&lt;a href=&#34;https://stable-baselines.readthedocs.io/en/master/guide/algos.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The stable-baselines documentation&lt;/a&gt; lists available RL algorithms and their compatibility.&lt;br&gt;
Due to the type of action space, some algorithms are not feasible (i.e. DDPG, SAC, and TD3).&lt;/p&gt;
&lt;p&gt;To train a stable-baselines RL algorithm, the &lt;code&gt;TuggerEnv&lt;/code&gt; is vectorized, using a &lt;code&gt;DummyVecEnv&lt;/code&gt; and a standard &lt;code&gt;MlpPolicy&lt;/code&gt;.
To leverage multiple CPUs for training, it can be desirable to use a &lt;code&gt;SubprocVecEnv&lt;/code&gt; (but for simpler logging &amp;amp; analysis we did not go with that one here, instead we did multiple independent training runs in parallel).&lt;/p&gt;
&lt;p&gt;Train an ACER-agent (by default for 10,000 steps only, which should take &amp;lt;1min):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker-compose up acer-training
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Plot performance (might require additional setup for connecting the display):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker-compose up acer-plot-training
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tilemap-animation of the trained agent (&lt;a href=&#34;http://localhost:5000&#34;&gt;http://localhost:5000&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker-compose up acer-web-animation-tilemap
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Below we can see an ACER-agent trained for 1m steps:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;gifs/tilemap_acer_1e6.gif&#34; alt=&#34;tilemap_acer_1e6&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As we can see, the agent manages to fully load the 25 units onto the tugger most of the time, seems to target correct (A/B) stations for material unloading, and the choice of stations with a currently low inventory level seems reasonable too!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;But how does the overall performance look like?&lt;/p&gt;
&lt;h3 id=&#34;performance-comparison&#34;&gt;Performance Comparison&lt;/h3&gt;
&lt;p&gt;For comparison we trained four algorithms (ACER, ACKTR, DQN, and PPO2) with standard settings for both 1 and 3 mio. (Gym-)steps.
Training took up to 2.5 hours (DQN, 3mio. steps) on a 2.9GHz Intel i9, using a single-process DummyVecEnv as explained above.&lt;br&gt;
The following graph shows the number of produced products per episode (24h) over the course of the training run for each algorithm, as well as the performance of the deterministic lowest-inventory heuristics (yellow line; always delivering a complete load of 25 units to the station with the currently lowest inventory), and the average performance of fully random actions (turquoise line, measured over 100 episodes).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;graphs/training_progress.png&#34; alt=&#34;performance-comparision-graph&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As we can see, all of the algorithms manage to increase the number of produced products per episode significantly above the level reached by random actions (turquoise line at the bottom), indicating successful learning progress.&lt;/li&gt;
&lt;li&gt;Furthermore, none of the trained algorithms reaches the performance of the lowest-inventory-heuristics (yellow line at the top).&lt;/li&gt;
&lt;li&gt;The lowest-inventory-heuristics performance reaches the estimated maximum possible throughput of the system (estimated to appr. 1080/episode). This strategy can therefore be considered to be close to a global optimum.&lt;/li&gt;
&lt;li&gt;During training, a complete breakdown in performance can occur. Most prominently: ACER_3mio. (blue line, episode 260, no recovery at all). Other algorithms show drops in performance as well but seem to recover better (e.g. ACKTR - green, PPO2 - pink).&lt;/li&gt;
&lt;li&gt;The best-performing RL algorithm (ACER trained for 1mio. steps, orange line) reached a maximum throughput of 856 products / episode (78% of the near-optimal heuristics performance).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The number of episodes varies due to the variable number of Gym-steps per episode (24h of simulated time), depending on the simulated time each Gym-step needs.
The small number of episodes of the ACER_3mio. training is explained by the up to 17277 Gym-steps per episode, occurring from episode 260 on.
Each step of such an episode takes only 5 seconds (the minimum possible time of all available Gym-steps, &amp;ldquo;achieved&amp;rdquo; by a repeated visit of the same location).
This behavior might be caused by the defined negative reward per step, proportional to the amount of simulated time the step needed.
Appearently, the agent does not remember how to generate a positive reward and only tries to maximize the short-term reward by minimizing the step-time.
Obviously this behavior does not lead to any successful delivery, let alone completion of any product.&lt;/p&gt;
&lt;p&gt;It is worth to be mentioned that all training runs were done with default algorithm settings, and that the evaluation of different hyperparameters is strongly 
&lt;a href=&#34;https://stable-baselines.readthedocs.io/en/master/guide/rl_tips.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;recommended&lt;/a&gt; for performance optimization.
Thus, it might not be improbable for an RL agent to close the performance gap towards the theoretically reachable optimum.&lt;/p&gt;
&lt;h2 id=&#34;summing-up&#34;&gt;Summing Up&lt;/h2&gt;
&lt;p&gt;Short version: Our best RL agent reached about 78% of the best possible performance inside our production-logistics environment.&lt;/p&gt;
&lt;p&gt;Ok, now is this good or bad?&lt;/p&gt;
&lt;p&gt;Well, one could be disappointed by the fact that our agent was not able to reach the performance of a hand-coded heuristics approach.&lt;br&gt;
But did we believe when we started that we could get a generic piece of code to cope with the non-trivial relations of our specific and fairly complex environment? Certainly not!&lt;br&gt;
And this was just a first shot - we did not yet start with hyperparameter tuning or the evaluation of alternative rewards.&lt;/p&gt;
&lt;p&gt;What do your experiences with reinforcement learning look like?&lt;br&gt;
Which logistics problems did you solve with RL?&lt;br&gt;
Did you spot a bug somewhere in the code or do you want to suggest an improvement?&lt;br&gt;
Or do you have questions concerning the presented implementation/toolstack?&lt;/p&gt;
&lt;p&gt;Just feel free to drop us a note, thanks for reading!&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.linkedin.com/in/wladimir-hofmann-9065a714b/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wladimir Hofmann&lt;/a&gt; - 
&lt;a href=&#34;https://www.linkedin.com/in/clemens-lennart-schwarz-609815186/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Clemens L. Schwarz&lt;/a&gt; - 
&lt;a href=&#34;https://www.linkedin.com/in/fredrik-branding-064014163/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fredrik Branding&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing Casymda</title>
      <link>/post/casymda/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0000</pubDate>
      <guid>/post/casymda/</guid>
      <description>&lt;p&gt;Discrete Event Simulation is a widespread tool for analysis and design of logistics systems.&lt;br&gt;
However, most industrial applications are realized using commercial simulators, and existing open-source alternatives still seem to lack some of the convenient features commercial packages are offering.&lt;br&gt;
The &lt;em&gt;Casymda&lt;/em&gt;-package strives to add some of these features, building on established standards such as BPMN and SimPy.&lt;/p&gt;
&lt;p&gt;This post will introduce main features and show how to run a simple example.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Get 
&lt;a href=&#34;https://github.com/fladdimir/casymda&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;the repo&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;existing-discrete-event-simulation-packages&#34;&gt;Existing Discrete Event Simulation Packages&lt;/h2&gt;
&lt;p&gt;Current applications of DES go beyond the traditional usage for systems planning.
They include more operational use-cases such as virtual commissioning or short-term forecasts &amp;amp; optimization.
Consequently, simulation models are getting integrated tightly into other IT-systems.
This allows to increase process transparency and to improve our means to analyze, control, and optimize system performance.&lt;/p&gt;
&lt;p&gt;Most industrial simulation uses are still based on commercial packages.&lt;/p&gt;
&lt;p&gt;And there are good reasons for this.&lt;br&gt;
If you&amp;rsquo;ve already worked with commercial DES packages (such as Anylogic/Arena/ExtendSim/FlexSim/PlantSimulation/Simio/&amp;hellip;YouNameIt), you probably learned to like some typical characteristics:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;block-based graphical modeling of processes&lt;/li&gt;
&lt;li&gt;(often) vendor-specific scripting possibilities to define custom behavior and non-standard procedures (this is where things get fun)&lt;/li&gt;
&lt;li&gt;(3D) visualization / animation capabilities for debug / validation / presentation (fun as well, most of the time)&lt;/li&gt;
&lt;li&gt;domain-specific libraries with objects providing pre-built industry-specific behaviors (configuration and customization)&lt;/li&gt;
&lt;li&gt;interfacing options: spreadsheets, databases, socket, COM,&amp;hellip; (what&amp;rsquo;s the last one?)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, there are a couple of open-source alternatives too.&lt;br&gt;
Even though they tend to lack some of the commercial features described above, there are upsides such as better scalability and simplified interfacing.&lt;/p&gt;
&lt;p&gt;Related to Python there are (at least) two popular DES packages: 
&lt;a href=&#34;https://www.salabim.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Salabim&lt;/a&gt; and 
&lt;a href=&#34;https://simpy.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SimPy&lt;/a&gt;.
Both are not only free and open-source, but even built on top of the standard library of one of the world&amp;rsquo;s most popular programming languages.&lt;/p&gt;
&lt;h2 id=&#34;casymda-features--implementation&#34;&gt;Casymda: Features &amp;amp; Implementation&lt;/h2&gt;
&lt;p&gt;Based on SimPy3, 
&lt;a href=&#34;https://pypi.org/project/casymda/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;Casymda&lt;/em&gt;&lt;/a&gt; adds bits of complementing functionality to gain some of the modeling convenience of commercial &amp;ldquo;block-based&amp;rdquo; DES-packages.&lt;br&gt;
It facilitates the usage of bpmn-process-descriptions to generate corresponding simulation-model python-code.
.bpmn-files (basically xml) can easily be created with the 
&lt;a href=&#34;http://www.bpmn.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Camunda-Modeler&lt;/a&gt;.&lt;br&gt;
This graphical modeling helps to maintain an overview of the high-level model-structure.
Generated Casymda-models also include a generic, token-like animation of simulated processes out-of-the-box, ready to be run in a web-browser.
For presentation and debugging, animations can be paused and their speed can be changed dynamically.
Solely animation-related events are not scheduled if the simulation is run without visualization.
This maximizes the execution speed - which becomes especially important when a high number of runs is necessary.&lt;br&gt;
Further features of Casymda include simulated movements along shortest paths in a 2D-tilemap-space, and gradual typing for development convenience (checkout 
&lt;a href=&#34;https://github.com/microsoft/pyright&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pyright&lt;/a&gt; if you are using 
&lt;a href=&#34;https://code.visualstudio.com/docs/python/editing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;vscode&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s have a quick look at a 
&lt;a href=&#34;https://github.com/fladdimir/casymda/tree/github/examples/tilemap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;simple example Casymda-model&lt;/a&gt;, illustrating some basic ideas.&lt;/p&gt;
&lt;p&gt;The animation below shows a simple process consisting of 3 Casymda-&lt;em&gt;blocks&lt;/em&gt;: &lt;code&gt;Entities&lt;/code&gt; are created in a &lt;code&gt;Source&lt;/code&gt;, pass a process-step called &lt;code&gt;TilemapMovement&lt;/code&gt;, and leave the system via a &lt;code&gt;Sink&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./gifs/tilemap_process_simple_x50.gif&#34; alt=&#34;simple animated simulation process&#34;&gt;&lt;/p&gt;
&lt;p&gt;To run the example just enter the following command from within the repository and visit &lt;a href=&#34;http://localhost:5000&#34;&gt;http://localhost:5000&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker-compose up web-animation-tilemap-simple-process
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Created block-objects can be parametrized with arguments provided as text-annotations (e.g. the &lt;code&gt;inter_arrival_time=100&lt;/code&gt; [seconds] of the entities at the source).
The naming of blocks is parsed following the pattern &lt;em&gt;ClassName&lt;/em&gt;:&lt;em&gt;instance_name&lt;/em&gt;.
The default process-animation includes additional information on the processed entities and on the state of each block.&lt;/p&gt;
&lt;p&gt;The way in which animations are created by Casymda is inspired by the 
&lt;a href=&#34;https://cloud.anylogic.com/models&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Anylogic implementation&lt;/a&gt;.
A web-server is running the actual simulation, and providing frame information to be rendered by a browser.
The corresponding Casymda functionality is implemented using 
&lt;a href=&#34;https://palletsprojects.com/p/flask/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;flask&lt;/a&gt; and 
&lt;a href=&#34;https://www.pixijs.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pixijs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Below you can find an &lt;em&gt;tilemap-animation&lt;/em&gt; of the &lt;code&gt;TilemapMovement&lt;/code&gt; process step of the model. As specified in the text-annotation, entities move &lt;code&gt;from_node=&amp;quot;A&amp;quot;&lt;/code&gt;, &lt;code&gt;to_node=&amp;quot;C&amp;quot;&lt;/code&gt;.
Tilemaps can be provided in &lt;code&gt;.csv&lt;/code&gt; format, with field values indicating possible origin/destination nodes (e.g. &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;), passable nodes (&lt;code&gt;0&lt;/code&gt;), and impassable nodes (&lt;code&gt;1&lt;/code&gt;).
The size of each tile is configured as part of the tilemap configuration.
Shortest paths and distances between all origin/destination nodes are computed using 
&lt;a href=&#34;https://networkx.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;networkx&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./gifs/tilemap_simple_x10.gif&#34; alt=&#34;simple animated tilemap simulation&#34;&gt;&lt;/p&gt;
&lt;p&gt;To run the tilemap animation example just enter the following command and visit: &lt;a href=&#34;http://localhost:5000&#34;&gt;http://localhost:5000&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker-compose up web-animation-tilemap-simple
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;additional-resources&#34;&gt;Additional resources&lt;/h2&gt;
&lt;p&gt;For additional information, feel free to have a look at 
&lt;a href=&#34;https://casymda.github.io/page/Webpage/Startpage.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;other projects built with Casymda&lt;/a&gt; (German).&lt;/p&gt;
&lt;p&gt;Interested in machine-learning? The next post will show how to use a Casymda-model to train a reinforcement learning algorithm to solve a production logistics problem - stay tuned ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Implementation of an IoT- and Cloud-based Digital Twin for Real-Time Decision Support in Port Operations</title>
      <link>/publication/mim2019/</link>
      <pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate>
      <guid>/publication/mim2019/</guid>
      <description>&lt;p&gt;Presented at: 9th IFAC Conference on Manufacturing Modelling, Management and Control 2019, Berlin, Germany&lt;/p&gt;
&lt;p&gt;Full text 
&lt;a href=&#34;https://www.researchgate.net/publication/320434207_A_Simulation_Tool_to_Assess_the_Integration_of_Cargo_Bikes_into_an_Urban_Distribution_System&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;on researchgate&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Simulation and Virtual Commissioning of Modules for a Plug-and-Play Conveying System</title>
      <link>/publication/incom2018/</link>
      <pubDate>Mon, 11 Jun 2018 00:00:00 +0000</pubDate>
      <guid>/publication/incom2018/</guid>
      <description>&lt;p&gt;Presented at: 16th IFAC Symposium on Information Control Problems in Manufacturing, June 11-13 2018, Bergamo, Italy&lt;/p&gt;
&lt;p&gt;Full text 
&lt;a href=&#34;https://www.researchgate.net/publication/324825135_Simulation_and_Virtual_Commissioning_of_Modules_for_a_Plug-and-Play_Conveying_System&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;on researchgate&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Simulation Tool to Assess the Integration of Cargo Bikes into an Urban Distribution System</title>
      <link>/publication/i3m2017/</link>
      <pubDate>Mon, 18 Sep 2017 00:00:00 +0000</pubDate>
      <guid>/publication/i3m2017/</guid>
      <description>&lt;p&gt;Presented at: International Workshop on Simulation for Energy, Sustainable Development &amp;amp; Environment, September 18-20 2017, Barcelona, Spain&lt;/p&gt;
&lt;p&gt;Full text 
&lt;a href=&#34;https://www.researchgate.net/publication/320434207_A_Simulation_Tool_to_Assess_the_Integration_of_Cargo_Bikes_into_an_Urban_Distribution_System&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;on researchgate&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
